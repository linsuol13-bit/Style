
<!DOCTYPE html>

<html lang="ko">
<head>

<script>
// Force tags to come ONLY from explicit item.tags, never auto-generated.
(function(){
  function ensureArray(x){ if(!x) return []; if(Array.isArray(x)) return x; return String(x).split(/[,\s#]+/).filter(Boolean); }
  window.parseTags = window.parseTags || function(str){ return ensureArray(str); };
  window.getItemTags = function(it){
    try { return ensureArray((it && it.tags) ? it.tags : ''); }
    catch(e){ return []; }
  };
  // Back-compat: provide tgs helper if templates expect it
  window.__tagsFromItem = function(it){ return window.getItemTags(it); };
})();
</script>

<meta charset="utf-8"/><meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>스타일라잇 점수계산</title>
<style>
*{box-sizing:border-box}body{font-family:system-ui,AppleSDGothicNeo,Segoe UI,Roboto,Apple Color Emoji,Noto Color Emoji,sans-serif;margin:0;background:#f7f7fb;color:#222}
header{padding:14px 20px;background:#fff;border-bottom:1px solid #eee;top:0;z-index:3}
h1{margin:0 0 6px 0;font-size:20px}
nav.tabs{display:flex;gap:8px;padding:10px 20px;border-bottom:1px solid #eee;background:#fff;top:56px;z-index:2justify-content:center;}
.tab{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:10px;cursor:pointer} .tab.active{background:#f0f7ff;border-color:#cfe4ff}
#controls{display:flex;gap:12px;align-items:end;flex-wrap:wrap;padding:12px 20px;background:#fff;top:100px;z-index:1;border-bottom:1px solid #eee}
#controls>div{display:flex;flex-direction:column;gap:6px}
select,textarea,input[type=text],button{padding:8px;border:1px solid #ddd;border-radius:8px;background:#fff}
button{cursor:pointer} button:hover{background:#fafafa}
#tips{padding:6px 20px}
.pill{display:inline-block;margin:4px 6px 0 0;padding:6px 10px;background:#eef6ff;border:1px solid #cfe4ff;border-radius:999px;font-size:12px}
#skills{padding:0 20px 6px 20px}
.skill{display:inline-block;margin:4px 6px 0 0;padding:6px 10px;background:#f4f1ff;border:1px solid #e0daff;border-radius:999px;font-size:12px}
#ownedBox{padding:0 20px 8px 20px}
#list{padding:8px 20px;display:grid;grid-template-columns:repeat(auto-fill,minmax(300px,1fr));gap:12px}
.card{background:#fff;border:1px solid #eee;border-radius:14px;padding:12px;box-shadow:0 1px 0 rgba(0,0,0,0.02);display:flex;flex-direction:column;gap:8px}
.card h3{margin:0 0 4px 0;font-size:16px;display:flex;justify-content:space-between;align-items:center}
.badges{display:flex;gap:6px;flex-wrap:wrap;margin-bottom:6px}
.badge{font-size:11px;border:1px solid #eee;padding:4px 8px;border-radius:999px;background:#fafafa}

.badge.tag{background:#fff0fb;border-color:#ffd1f3}
.badges.tags{margin-top:2px}
.badge.owned{background:#eaffea;border-color:#cdeccc}
.score{font-weight:700}
.small{color:#666;font-size:12px}
.empty{padding:24px 20px;color:#666}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.muted{color:#777;font-size:12px}
.copy-btn{font-size:12px;padding:6px 8px;border-radius:8px}
.toast{left:50%;bottom:20px;transform:translateX(-50%);background:#222;color:#fff;padding:8px 12px;border-radius:10px;opacity:0;transition:opacity .2s,transform .2s;pointer-events:none}
.toast.show{opacity:1;transform:translateX(-50%) translateY(-4px)}
details.tagbox{padding:0 20px} details.tagbox summary{cursor:pointer;user-select:none;padding:6px 0;color:#333}
.tags-panel{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:6px;padding:8px;border:1px solid #eee;border-radius:10px;background:#fff}
.tag-chip{display:flex;gap:6px;align-items:center;font-size:12px;padding:6px 8px;border:1px solid #eee;border-radius:999px;background:#fafafa}
.tag-chip input{margin:0}
.tag-bar{padding:0 20px 8px 20px} .tag-pill{display:inline-block;margin:4px 6px 0 0;padding:4px 10px;background:#f4fbf4;border:1px solid #d9f0d9;border-radius:999px;font-size:12px}
.panel{display:none} .panel.active{display:block}
.table-wrap{padding:10px 20px}
table{width:100%;border-collapse:collapse;background:#fff;border:1px solid #eee;border-radius:12px;overflow:hidden}
th,td{padding:8px 10px;border-bottom:1px solid #f0f0f0;font-size:13px;vertical-align:middle}
thead th{top:0;background:#fafafa;z-index:1} /* sticky fix */
tbody tr:hover{background:#fafcff}
.nowrap{white-space:nowrap} .num{text-align:right}
.group table thead th{ top:auto !important}
.group{margin:14px 20px;border:1px solid #eee;border-radius:12px;background:#fff}
.group summary{padding:10px 12px;cursor:pointer;font-weight:600;border-bottom:1px solid #f5f5f5}
.group .inner{padding:10px 12px}
.countpill{display:inline-block;margin-left:8px;font-size:11px;background:#f0f7ff;border:1px solid #cfe4ff;border-radius:999px;padding:2px 8px}
/* thumbnails */
.thumb{width:44px;height:44px;border-radius:8px;object-fit:cover;border:1px solid #eee;background:#fafafa}
.thumb.sm{width:32px;height:32px;border-radius:6px}
.card .row.thumbrow{gap:10px;align-items:center}
.imgcol{width:44px;text-align:center}
/* Hide top totals (의상/스테이지/스킬) only */
.countbox{display:none !important}
#controls .muted{display:none !important}
#partCounts{display:flex;flex-wrap:wrap;gap:6px;padding:6px 20px}
#stageFilterBlock label{margin-right:6px}
/* align filters in one row */
#controls .filter-row{display:flex;align-items:center;gap:16px;flex-wrap:wrap}
#controls .filter-row label{margin-right:4px}
/* ensure labels and selects inline */
#controls .filter-row label{margin-right:6px;white-space:nowrap}
#controls .filter-row select{margin-right:16px}
/* Filter styling adjustments */
#controls .filter-row label,
#controls .filter-row select,
#controls .filter-row input[type=checkbox] {
  font-size: 13px;
}
#controls .filter-row {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}
#controls .filter-row .checkbox-inline {
  display: flex;
  align-items: center;
  gap: 4px;
  margin-left: 8px;
  white-space: nowrap;
}
/* Adjust filter alignment */
#controls .filter-row {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}
#controls .filter-row select,
#controls .filter-row label,
#controls .filter-row input[type=checkbox] {
  font-size: 13px;
}
#controls .filter-row .checkbox-inline {
  display: flex;
  align-items: center;
  gap: 4px;
  margin-left: 0;
  white-space: nowrap;
}
/* Tighter filter alignment */
#controls .filter-row {
  display: flex;
  align-items: center;
  gap: 2px; /* 최소 간격 */
  flex-wrap: wrap;
}
#controls .filter-row select,
#controls .filter-row label,
#controls .filter-row input[type=checkbox] {
  font-size: 12px;
  margin: 0;
  padding: 2px 4px;
}
#controls .filter-row .checkbox-inline {
  display: flex;
  align-items: center;
  gap: 2px;
  margin: 0;
  white-space: nowrap;
}
/* Ultra tight filter alignment */
#controls .filter-row {
  display: flex;
  align-items: center;
  justify-content: flex-start;
  gap: 0px; /* 완전히 붙이기 */
  flex-wrap: nowrap; /* 줄바꿈 방지 */
}
#controls .filter-row select,
#controls .filter-row label,
#controls .filter-row input[type=checkbox] {
  font-size: 12px;
  margin: 0;
  padding: 2px 4px;
}
#controls .filter-row .checkbox-inline {
  display: flex;
  align-items: center;
  gap: 2px;
  margin: 0;
  white-space: nowrap;
}
/* Match filter font size to tab font size */
#controls .filter-row label,
#controls .filter-row select,
#controls .filter-row input[type=checkbox] {
  font-size: 14px; /* 탭과 동일 크기 */
}
#controls .filter-row .checkbox-inline {
  font-size: 14px;
}
/* Match '보유 의상 이름' label and inputs to tab font size */
#ownedBox label,
#ownedBox textarea,
#ownedBox button {
  font-size: 14px;
}
/* Match action buttons to tab font size */
#ownedBox button {
  font-size: 14px !important;
}
#partCounts{ display:none !important; }
#partSummary{ display:none !important; }
.pill-small{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border:1px solid #e6e6e6;border-radius:999px;font-size:12px;background:#fff;cursor:pointer}
.pill-small .k{opacity:.75}
.pill-small .v{font-weight:600}
.partbar .pill-small:hover{background:#f2f2ff;border-color:#dcd8ff}
.small{font-size:12px}
.badge{display:inline-block;padding:2px 8px;border-radius:999px;background:#eef1ff;border:1px solid #dfe5ff}
.partbar-wrap .muted.small{font-size:12px;color:#666}
.gtab{border:1px solid #e6e6e6;background:#fff;border-radius:999px;padding:2px 10px;font-size:12px;cursor:pointer}
.gtab.is-on{background:#f2f2ff;border-color:#dcd8ff}
.chip{display:inline-flex;align-items:center;gap:6px;padding:3px 8px;border:1px solid #e6e6e6;border-radius:999px;font-size:12px;background:#fff;cursor:pointer}
.chip .k{opacity:.75}
.chip .v{font-weight:600}
.chip:hover{background:#f7f7ff;border-color:#dcd8ff}
#partFilter option.groupHdr{font-weight:700}

#itemsTable th, 
#itemsTable td,
#byPartWrap th,
#byPartWrap td {
  text-align: center;
}

</style>
<style>
</style>
<style>
/* Required item badge & checklist */
.badge.req{background:#fff3cd;border-color:#ffe8a1}
.reqlist{padding:6px 20px}
.reqlist .pill{display:inline-block;margin:4px 6px 0 0;padding:6px 10px;background:#fff7e0;border:1px solid #ffe8a1;border-radius:999px;font-size:12px}
.reqlist .own{background:#eaffea;border-color:#cdeccc}
.reqlist .miss{background:#ffecec;border-color:#ffd1d1}
.reqlist .part{font-weight:600;margin-right:8px}
</style>

<script>
/* === Runtime guard for required_parts keys (added) === */
(function(){
  if (!window._normalizeStageReq) {
    window._normalizeStageReq = function(stage){
      try{
        if(!stage || typeof stage!=='object') return stage;
        var rp = stage.required_parts || {};
        // Map legacy key "헤어" -> "헤어 스타일"
        if (rp["헤어"] && !rp["헤어 스타일"]) rp["헤어 스타일"] = rp["헤어"];
        // Ensure arrays for common parts
        var slots = ["헤어 스타일","모자","원피스","아우터","상의","하의","양말","신발"];
        for(var i=0;i<slots.length;i++){ var k=slots[i]; if(!Array.isArray(rp[k])) rp[k]=[]; }
        stage.required_parts = rp;
      }catch(e){/*noop*/}
      return stage;
    };
  }
})();
/* === End runtime guard === */

(function(){
  function showLoading(on){
    var el = document.getElementById('loading');
    if(!el) return;
    el.style.display = on ? 'block' : 'none';
  }
  // expose globally
  window._loading = { show: showLoading };
})();

/* === Additional hard guards (v2) === */
(function(){
  // Safe arrays
  window._asArr = function(x){ return Array.isArray(x) ? x : (x==null ? [] : [x]); };
  // Normalize stage.required_parts every time we read it
  const _origGetRequiredNameSet = window.getRequiredNameSet;
  window.getRequiredNameSet = function(){
    try{
      const sel = document.getElementById('stageSelect');
      const id = sel && sel.value;
      const st = (window.stages||[]).find(x=> String(x.stage_id)===String(id));
      window._normalizeStageReq && window._normalizeStageReq(st);
      const rp = st && st.required_parts || {};
      const names = new Set();
      Object.keys(rp||{}).forEach(k=>{
        const v = rp[k];
        if(Array.isArray(v)) v.forEach(n=> names.add((window.ownNorm||String)(n)));
        else if(v && typeof v==='object') Object.values(v).forEach(n=> names.add((window.ownNorm||String)(n)));
        else if(v!=null) names.add((window.ownNorm||String)(v));
      });
      return names;
    }catch(e){ return new Set(); }
  };

  // Harden getFilteredList against missing items/partFilter
  const _origGetFilteredList = window.getFilteredList;
  if(typeof _origGetFilteredList === 'function'){
    window.getFilteredList = function(stage){
      try{
        const partEl = document.getElementById('partFilter');
        const part = partEl ? partEl.value : '';
        const selectedTags=(window.getSelectedTags?window.getSelectedTags():[]);
        const mode=(document.querySelector('input[name="tagMode"]:checked')||{}).value||'AND';
        const src = Array.isArray(window.items)? window.items : [];
        let list = src.map(it=> ({...it, part:it.part, score:(window.scoreItemForStage?window.scoreItemForStage(it,stage):0)}));
        if(part) list=list.filter(it=> it.part===part);
        if(window.tagsInclude && window.parseTags) list=list.filter(it=> window.tagsInclude(window.parseTags(it.tags), selectedTags, mode));
        return list.map(it=> ({...it, _owned: (window.ownedNameSet && window.normOwnedName)? window.ownedNameSet.has(window.normOwnedName(it.name)) : false}));
      }catch(e){ return []; }
    };
  }

  // Wrap renderAll to never throw
  if(typeof window.renderAll==='function'){
    const _orig = window.renderAll;
    window.renderAll = function(){ try{ _orig(); }catch(e){} };
  }
})();
/* === End hard guards (v2) === */

</script>


<style>
.req-badge{display:inline-block;margin-left:6px;padding:2px 6px;border-radius:6px;border:1px solid #ff9b9b;background:#ffecec;color:#d40000;font-weight:600;font-size:12px}
.req-panel{margin:10px 20px;padding:10px;border:1px solid #f3d2d2;background:#fff6f6;border-radius:10px}
.req-panel h3{margin:0 0 8px 0;font-size:14px;color:#b10000}
.req-table{width:100%;border-collapse:collapse;font-size:13px}
.req-table th,.req-table td{border:1px solid #f1c9c9;padding:6px 8px;text-align:left}
.req-table th{background:#ffe3e3}
</style>

</head>
<body>
<div id="reqPanel" class="req-panel" style="display:none"></div>

<script>
// Kill MutationObserver globally (surgical, to stop any render loops)
try {
  window.MutationObserver = function(){ return { observe(){}, disconnect(){}, takeRecords(){ return [] } }; };
} catch(e){}
</script>

<!-- INLINE_DATA_REMOVED -->
<script>
// Global aliases and safety
window.items = window.items || [];
window.stages = window.stages || [];
window.ITEMS = window.items;
var items = window.items;
var stages = window.stages;
</script>
<nav class="tabs">
<button class="tab active" data-tab="calc">추천/점수</button>
<button class="tab" data-tab="table">의상 데이터(전체)</button>
<button class="tab" data-tab="by-part">의상 데이터(부위별)</button>
</nav>
<section id="controls">
<div><label>
<div class="filter-row">
<label for="stageSelect">스테이지 선택</label>
<select id="stageSelect"></select>
<label>부위 필터 (그룹)</label><select id="partFilter"><option value="">전체</option>
<optgroup label="의상">
<option value="헤어 스타일">헤어 스타일</option>
<option value="원피스">원피스</option>
<option value="아우터">아우터</option>
<option value="상의">상의</option>
<option value="하의">하의</option>
<option value="양말">양말</option>
<option value="신발">신발</option>
</optgroup>
<optgroup label="액세서리">
<option value="모자">모자</option>
<option value="헤어 장식">헤어 장식</option>
<option value="얼굴 장식">얼굴 장식</option>
<option value="귀걸이">귀걸이</option>
<option value="목걸이">목걸이</option>
<option value="소지품">소지품</option>
<option value="탑승물">탑승물</option>
</optgroup>
<optgroup label="팔찌">
<option value="손목 장식">손목 장식</option>
<option value="장갑">장갑</option>
<option value="반지">반지</option>
</optgroup>
<optgroup label="등 장식">
<option value="날개">날개</option>
<option value="꼬리">꼬리</option>
<option value="등 장식">등 장식</option>
</optgroup>
<optgroup label="특수 아이템">
<option value="발찌">발찌</option>
<option value="크로스백">크로스백</option>
<option value="블로팅">블로팅</option>
<option value="타투">타투</option>
</optgroup>
<optgroup label="메이크업">
<option value="아이브로우">아이브로우</option>
<option value="컬러 렌즈">컬러 렌즈</option>
<option value="아이라이너">아이라이너</option>
<option value="아이섀도우">아이섀도우</option>
<option value="립 메이크업">립 메이크업</option>
<option value="속눈썹">속눈썹</option>
<option value="블러셔">블러셔</option>
<option value="페이스 타투">페이스 타투</option>
</optgroup></select>
<label>정렬</label><select id="sortBy"><option value="score">점수순</option><option value="name">이름순</option></select>
<label><span class="checkbox-inline"><input id="ownedOnly" type="checkbox"/> 보유만 보기</span></label>
</div>
</label><div>
</div></div>
<div>
<div></div></div>
<div></div>
<div class="muted" style="align-self:center">의상 <span id="itemCount">0</span> · 스테이지 <span id="stageCount">0</span> · 스킬 <span id="skillCount">0</span></div>
</section>
<details class="tagbox">
<summary>태그 필터 (펼치기)</summary>
<div class="row" style="padding:6px 0">
<label><input checked="" name="tagMode" type="radio" value="AND"/> 모두 포함(AND)</label>
<label><input name="tagMode" type="radio" value="OR"/> 하나 이상(OR)</label>
<button id="clearTags">선택 해제</button>
</div>
<div class="tags-panel" id="tagsPanel"></div>
</details>
<div class="tag-bar" id="activeTags"></div>
<section class="panel active" id="panel-calc">
<section id="ownedBox">
<span class="badge" id="ownedSummary" style="margin-left:8px">보유 0 / 전체 0</span>

<div class="row">
<div class="chiprow" id="partChips" style="display:flex;gap:6px;overflow:auto;white-space:nowrap;margin-top:6px"></div>
</div>
<div id="partTabsWrap" style="margin:4px 0">
<div id="partTabs" style="display:flex;gap:6px;align-items:center">
<button class="gtab is-on" data-g="wear">의상</button>
<button class="gtab" data-g="acc">액세사리</button>
<button class="gtab" data-g="makeup">메이크업</button>
</div>
<div class="chiprow" id="partChips" style="display:flex;gap:6px;overflow:auto;white-space:nowrap;margin-top:6px"></div>
</div>
<div><label for="ownedInput" style="display:block;margin:4px 0;font-weight:500">보유 의상 이름 (줄바꿈/쉼표/공백 구분)</label></div>
<textarea id="ownedInput" placeholder="예) 석양의 날개" style="min-width:420px;min-height:84px"></textarea>
<div class="owned-buttons" style="margin-top:6px; display:flex; gap:8px; flex-wrap:wrap">
<button id="exportOwned" type="button">내보내기(.txt)</button>
<button id="importOwned" type="button">불러오기(.txt)</button>
<input accept=".txt" id="importOwnedFile" style="display:none" type="file"/>
</div>
<div class="row" style="align-items:flex-start"></div>

<div <div="" clas="" class="chiprow" id="partChips" style="display:flex;gap:6px;overflow:auto;white-space:nowrap;margin-top:6px"></div>


<section id="partSummary" style="margin:10px 0 4px 0">
<div class="row" style="align-items:center;gap:8px">
<h3 style="margin:0;font-size:14px">부위별 개수</h3>
<span class="muted" style="font-size:12px">보유 / 전체(등록)</span>
</div>
<div class="table-wrap" style="margin-top:6px">
<table class="table small" id="partSummaryTable" style="min-width:520px">
<thead>
<tr>
<th style="width:40%">부위</th>
<th style="width:20%">보유</th>
<th style="width:20%">전체</th>
<th style="width:20%">보유율</th>
</tr>
</thead>
<tbody></tbody>
</table>
</div>
<div class="muted" style="font-size:12px">행을 클릭하면 해당 부위로 필터가 적용됩니다.</div>
</section>
</section>
<section id="tips"></section><section id="skills"></section>
<div class="empty" id="emptyState">아직 내장된 데이터가 없습니다. 의상/스테이지/스킬을 보내주시면 이 파일에 반영해 드릴게요.</div>
<section id="list" style="display:none"></section>
<div class="toast" id="toast">복사됨</div>
</section>
<section class="panel" id="panel-table">
<div class="table-wrap">
<div class="row" style="justify-content:space-between;padding:6px 0">
<div class="muted">현재 선택된 스테이지 가중치로 <b>계산 점수</b>가 표시됩니다.</div>
<div class="row"><input id="tableSearch" placeholder="이름/부위/태그 검색" style="min-width:220px" type="text"/><button id="tableClear">지우기</button></div>
</div>
<div style="overflow:auto;max-height:70vh">
<table id="itemsTable">
<thead><tr>
<th class="nowrap imgcol">이미지</th><th class="nowrap">부위</th><th class="nowrap">이름</th><th class="num nowrap">별</th>
<th>화려</th><th>심플</th><th>우아</th><th>활발</th><th>시크</th>
<th>큐티</th><th>섹시</th><th>청순</th><th>청량</th><th>포근</th>
<th>태그</th><th class="num nowrap">계산 점수</th>
</tr></thead>
<tbody></tbody>
</table>
</div>
</div>
</section>
<section class="panel" id="panel-by-part">
<div class="table-wrap" id="byPartWrap"></div>
</section>
<script>
const PART_SYNONYM = {"엑세사리 - 얼굴 장식":"얼굴 장식","엑세사리 - 귀걸이":"귀걸이","엑세사리 - 목걸이":"목걸이","엑세사리 - 팔찌 - 손목  장식":"손목 장식","엑세사리 - 팔찌 - 장갑":"장갑","엑세사리 - 특수 아이템 - 발찌":"발찌","엑세사리 - 특수 아이템 - 크로스백":"크로스백"};
const normalizePart = (p)=> PART_SYNONYM[String(p||'').trim()] || String(p||'').trim();

const TAG_CATALOG_FULL = [
  "걸그룹스타일",
  "겨울옷",
  "고딕러블리",
  "고딕풍",
  "꾸안꾸",
  "내추럴",
  "댄서",
  "도망친공주",
  "동심풍스타일",
  "동화풍",
  "드레스",
  "러블리스타일",
  "록스타일",
  "모리걸",
  "목욕",
  "바캉스스타일",
  "빈티지스타일",
  "사이버퓨처",
  "성숙한스타일",
  "수영복",
  "스윗러블리",
  "스쿨룩",
  "스트릿펑크",
  "애니멀",
  "에스닉",
  "엘프",
  "영국풍",
  "오피스룩",
  "우산",
  "운동룩",
  "워크웨어",
  "웨딩드레스",
  "유니폼룩",
  "유럽시골풍",
  "유럽풍",
  "유럽풍판타지",
  "이브닝드레스",
  "이집트스타일",
  "일본풍",
  "자외선차단",
  "젠더리스",
  "중국무형유산풍",
  "중국풍",
  "차이나시크",
  "클래식러블리",
  "트렌디스냅샷",
  "하이엔드",
  "핫걸",
  "홈웨어"
];

// 내장 아이템 2개 (이미지 포함), "성숙" 대신 "시크"
/* items moved to iframe v2 */

// 스테이지 가중치도 "시크" 필드 포함
const STAGES_FALLBACK = []; // disabled: use window.stages from iframe

const gradeScore = {"SSS": 3200.0, "SS": 2612.7, "S": 2089.35, "A": 1690.65, "B": 1309.8, "C": 817.5, "-": 0, "": 0, "null": 0};
const PART_WEIGHTS = {"헤어 스타일": 0.5, "원피스": 2, "아우터": 0.2, "상의": 1, "하의": 1, "양말": 0.3, "신발": 0.4, "장식": 0.2, "뷰티": 0.1};
const STAR_MULT = [1.00, 1.00, 1.03, 1.06, 1.09, 1.12, 1.15];
const starMultiplier = (stars)=> STAR_MULT[Math.max(0, Math.min(6, Number(stars||0)))] || 1.00;

const OWNED_KEY = 'nikki_owned_names';
window.ownedNameSet = window.ownedNameSet || new Set();
let ownedNameSet = window.ownedNameSet;
const normName = (s)=> String(s||'').normalize('NFKC').replace(/\s+/gu,' ').trim().toLowerCase();
  window.normOwnedName = (s)=> String(s||'').normalize('NFKC').toLowerCase().replace(/\s+/gu,'');
const toNum = (v)=> isNaN(Number(v)) ? 0 : Number(v);
const by = (k) => (a,b)=> (a[k] < b[k] ? -1 : a[k] > b[k] ? 1 : 0);
const parseTags = (t)=> String(t||'').split(/[;,\s]+/).map(s=>s.trim()).filter(Boolean);
const gradeToScore = (g)=> gradeScore[(g||'').toString().toUpperCase()] ?? 0;

function tagsInclude(itemTags, selected, mode){ if(selected.length===0) return true; const set=new Set(itemTags); return mode==='OR'? selected.some(t=>set.has(t)) : selected.every(t=>set.has(t)); }

function scoreItemForStage(item, stage){
  const attrs=['flair','simple','elegant','lively','chic','cute','sexy','pure','cool','warm']; // 시크 포함
  if(!stage) return 0;
  const factor=(toNum(stage.weight||9))/9; const stageW={...stage}; attrs.forEach(a=> stageW[a]=toNum(stageW[a]||0)*factor);
  let base=0; for(const a of attrs) base += toNum(stageW[a]) * gradeToScore(item[a]);
  return base * starMultiplier(item.stars) * (PART_WEIGHTS[item.part]||1);
}

function buildTagPanel(){
  const panel=document.getElementById('tagsPanel');
  panel.innerHTML = TAG_CATALOG_FULL.map(t=>`<label class="tag-chip"><input type="checkbox" value="${t}" data-tagcb><span>${t}</span></label>`).join('');
  document.getElementById('clearTags').addEventListener('click', ()=>{ panel.querySelectorAll('input[data-tagcb]').forEach(cb=> cb.checked=false); renderAll(); });
  panel.addEventListener('change', renderAll);
  document.querySelectorAll('input[name="tagMode"]').forEach(r=> r.addEventListener('change', renderAll));
}
const getSelectedTags = ()=> Array.from(document.querySelectorAll('#tagsPanel input[data-tagcb]:checked')).map(cb=> cb.value);
function showActiveTags(){
  const wrap=document.getElementById('activeTags'); const selected=getSelectedTags();
  const mode=document.querySelector('input[name="tagMode"]:checked')?.value || 'AND';
  wrap.innerHTML = selected.map(t=> `<span class="tag-pill">${t}</span>`).join('') + (selected.length? ` <span clas(${mode})</span>` : '');
}

function showToast(msg='복사됨'){ const t=document.getElementById('toast'); t.textContent=msg; t.classList.add('show'); setTimeout(()=> t.classList.remove('show'), 1000); }
async function copyText(text){
  try{ await navigator.clipboard.writeText(text); showToast('복사됨: '+text); }
  catch(e){ const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta); ta.select(); try{ document.execCommand('copy'); showToast('복사됨: '+text); }catch{ alert('복사 실패'); } finally{ ta.remove(); } }
}

function activateTab(name){ document.querySelectorAll('.tab').forEach(b=> b.classList.toggle('active', b.dataset.tab===name));
  document.querySelector('#panel-calc').classList.toggle('active', name==='calc');
  document.querySelector('#panel-table').classList.toggle('active', name==='table');
  document.querySelector('#panel-by-part').classList.toggle('active', name==='by-part'); }

function labelGrade(it){ const g=k=> it[k]||'-'; return [`화려 ${g('flair')}`,`심플 ${g('simple')}`,`우아 ${g('elegant')}`,`활발 ${g('lively')}`,`시크 ${g('chic')}`,`큐티 ${g('cute')}`,`섹시 ${g('sexy')}`,`청순 ${g('pure')}`,`청량 ${g('cool')}`,`포근 ${g('warm')}`].join(' / '); }

function getFilteredList(stage){
  const part=document.getElementById('partFilter').value;
  const selectedTags=getSelectedTags(); const mode=document.querySelector('input[name="tagMode"]:checked')?.value || 'AND';
  let list=items.map(it=> ({...it, part:it.part, score:scoreItemForStage(it, stage)}));
  if(part) list=list.filter(it=> it.part===part);
  list=list.filter(it=> tagsInclude(parseTags(it.tags), selectedTags, mode));
  return list.map(it=> ({...it, _owned: window.ownedNameSet.has(window.normOwnedName(it.name))}));
}

function render(){
  const stageId=document.getElementById('stageSelect').value || (stages[0] && stages[0].stage_id);
  const sortBy=document.getElementById('sortBy').value;
  const ownedOnly=document.getElementById('ownedOnly').checked;
  const stage=stages.find(s=> s.stage_id===stageId) || stages[0];
  showActiveTags();
  let list=getFilteredList(stage);
  if(ownedOnly) list=list.filter(it=> it._owned);
  if(sortBy==='score') list.sort((a,b)=> b.score-a.score); else list.sort(by('name'));

  const listEl=document.getElementById('list'); const empty=document.getElementById('emptyState');
  if(list.length===0){ listEl.style.display='none'; empty.style.display='block'; }
  else { listEl.style.display='grid'; empty.style.display='none'; }

  listEl.innerHTML = list.map(it=>{
    const stars=Math.max(0, Math.min(6, Number(it.stars||0)));
    const tgs = parseTags((it && it.tags) ? it.tags : '');
    const img = it.img ? `<img class="thumb" src="${it.img}" alt="${it.name}">` : '';
    return `<div class="card">
      <div class="row thumbrow">${img}<h3 style="margin:0;flex:1;display:flex;justify-content:space-between;align-items:center">
        <span>${it.name||'-'}</span>
        <button class="copy-btn" onclick="copyText('${(it.name||'').replace(/'/g, "\'")}')">이름 복사</button>
      </h3></div>
      <div class="badges"><span class="badge">${it.part||'-'}</span><span class="badge">${stars}★</span>${it._owned?'<span class="badge owned">보유</span>':''}</div>
      <div class="badges tags">${tgs.map(x=>`<span class='badge tag'>#${x}</span>`).join('')}</div>
      <div class="score">점수: ${Number(it.score).toFixed(2)}</div>
      <div class="small">${labelGrade(it)}</div>
    </div>`;
  }).join('');
}

function renderTable(){
  const stageId=document.getElementById('stageSelect').value || (stages[0] && stages[0].stage_id);
  const stage=stages.find(s=>s.stage_id===stageId) || stages[0];
  const q=(document.getElementById('tableSearch').value||'').trim().toLowerCase();
  let list=getFilteredList(stage);
  if(q) list=list.filter(it=> (`${it.name} ${it.part} ${it.tags}`).toLowerCase().includes(q));
  const tbody=document.querySelector('#itemsTable tbody');
  tbody.innerHTML = list.map(it=>{
    const tgs=parseTags(it.tags).join(', ');
    const img = it.img ? `<img class="thumb sm" src="${it.img}" alt="${it.name}">` : '';
    return `<tr>
      <td>${img}</td><td>${it.part||''}</td><td>${it.name||''}</td><td class="num">${it.stars||0}</td>
      <td>${it.flair||'-'}</td><td>${it.simple||'-'}</td><td>${it.elegant||'-'}</td>
      <td>${it.lively||'-'}</td><td>${it.chic||'-'}</td>
      <td>${it.cute||'-'}</td><td>${it.sexy||'-'}</td>
      <td>${it.pure||'-'}</td><td>${it.cool||'-'}</td><td>${it.warm||'-'}</td>
      <td>${tgs}</td><td class="num">${Number(it.score).toFixed(2)}</td>
    </tr>`;
  }).join('');
}

function renderByPart(){
  const stageId=document.getElementById('stageSelect').value || (stages[0] && stages[0].stage_id);
  const stage=stages.find(s=>s.stage_id===stageId) || stages[0];
  let list=getFilteredList(stage);
  const groups={}; for(const it of list) (groups[it.part]=groups[it.part]||[]).push(it);
  const wrap=document.getElementById('byPartWrap'); const partsSorted=Object.keys(groups).sort();
  wrap.innerHTML = partsSorted.map(part=>{
    const arr=groups[part].slice().sort((a,b)=> b.score-a.score);
    const rows=arr.map(it=>{
      const tgs=parseTags(it.tags).join(', ');
      const img = it.img ? `<img class="thumb sm" src="${it.img}" alt="${it.name}">` : '';
      return `<tr>
        <td>${img}</td><td>${it.name||''}</td><td class="num">${it.stars||0}</td>
        <td>${it.flair||'-'}</td><td>${it.simple||'-'}</td><td>${it.elegant||'-'}</td>
        <td>${it.lively||'-'}</td><td>${it.chic||'-'}</td>
        <td>${it.cute||'-'}</td><td>${it.sexy||'-'}</td>
        <td>${it.pure||'-'}</td><td>${it.cool||'-'}</td><td>${it.warm||'-'}</td>
        <td>${tgs}</td><td class="num">${Number(it.score).toFixed(2)}</td>
      </tr>`;
    }).join('');
    return `<details class="group" open>
      <summary>${part} <span class="countpill">${arr.length}</span></summary>
      <div class="inner"><div style="overflow:auto;max-height:50vh">
        <table>
          <thead><tr>
            <th class="nowrap">이미지</th><th class="nowrap">이름</th><th class="num nowrap">별</th>
            <th>화려</th><th>심플</th><th>우아</th><th>활발</th><th>시크</th>
            <th>큐티</th><th>섹시</th><th>청순</th><th>청량</th><th>포근</th>
            <th>태그</th><th class="num nowrap">계산 점수</th>
          </tr></thead>
          <tbody>${rows}</tbody>
        </table>
      </div></div>
    </details>`;
  }).join('') || '<div class="empty">표시할 데이터가 없습니다.</div>';
}

function renderAll(){ render(); renderTable(); renderByPart(); }

function init(){
  document.getElementById('itemCount').textContent = (window.items||[]).length;
  document.getElementById('stageCount').textContent = (window.stages||[]).length;
  document.getElementById('skillCount').textContent = 0;
  // 태그
  const panel=document.getElementById('tagsPanel');
  panel.innerHTML = TAG_CATALOG_FULL.map(t=>`<label class="tag-chip"><input type="checkbox" value="${t}" data-tagcb><span>${t}</span></label>`).join('');
  document.getElementById('clearTags').addEventListener('click', ()=>{ panel.querySelectorAll('input[data-tagcb]').forEach(cb=> cb.checked=false); renderAll(); });
  panel.addEventListener('change', renderAll);
  document.querySelectorAll('input[name="tagMode"]').forEach(r=> r.addEventListener('change', renderAll));

  // 컨트롤
  ['stageSelect','partFilter','sortBy','ownedOnly'].forEach(id=> document.getElementById(id).addEventListener('change', renderAll));
  document.getElementById('tableSearch').addEventListener('input', renderTable);
  document.getElementById('tableClear').addEventListener('click', ()=>{ document.getElementById('tableSearch').value=''; renderTable(); });
  // 탭
  document.querySelectorAll('.tab').forEach(b=> b.addEventListener('click', ()=> activateTab(b.dataset.tab)));
  // 스테이지 선택
  document.getElementById('stageSelect').innerHTML = stages.map(s=> `<option value="${s.stage_id}">${s.stage_id}</option>`).join('');
  renderAll();
}
document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; /* wait for data via iframes */ });

function countByPart(){
  const c = {};
  (items||[]).forEach(it=>{ c[it.part] = (c[it.part]||0)+1; });
  return c;
}
function renderPartCounts(){
  const wrap = document.getElementById('partCounts');
  if(!wrap) return;
  const counts = countByPart();
  wrap.innerHTML = Object.entries(counts).map(([p,n])=>`<span class="pill">${p}: ${n}</span>`).join("");
}
document.addEventListener('DOMContentLoaded', renderPartCounts);
</script>
<script>
// --- Deduplicate and update "마음의 주말" ---
(function(){
  const arr = (window.items || window.ITEMS || []);
  const keyOf = (it)=> (String(it?.part||'').trim() + "@@" + String(it?.name||'').trim());
  const seen = new Map();
  const dedup = [];
  const copyIfBetter = (tgt, src, p) => {
    const sv = src[p];
    if(sv === undefined || sv === null) return;
    const s = String(sv).trim();
    const tv = tgt[p];
    const t = (tv === undefined || tv === null) ? "" : String(tv).trim();
    if(t === "" || t === "-" ) tgt[p] = sv; // fill empty/placeholder
  };
  const mergeBonus = (tgt, src, p) => {
    const sv = Number(src[p]);
    if(!Number.isFinite(sv)) return;
    const tv = Number(tgt[p]);
    if(!Number.isFinite(tv) || sv !== tv) tgt[p] = sv;
  };
  for(const it of arr){
    const k = keyOf(it);
    if(!seen.has(k)){
      seen.set(k, it);
      dedup.push(it);
    }else{
      const tgt = seen.get(k);
      ["stars","img","tags","flair","simple","elegant","lively","chic","cute","sexy","pure","cool","warm"]
        .forEach(p=> copyIfBetter(tgt, it, p));
      ["flair_bonus","simple_bonus","elegant_bonus","lively_bonus","chic_bonus","cute_bonus","sexy_bonus","pure_bonus","cool_bonus","warm_bonus"]
        .forEach(p=> mergeBonus(tgt, it, p));
    }
  }
  window.items = dedup;

  // Ensure target item exists and is updated with latest data

  let target = window.items.find(it=> String(it.part).trim()==="원피스" && String(it.name).trim()==="마음의 주말");
  if(target){ Object.assign(target, updated); }
  else { window.items.push(updated); }

  // --- Patch score function to include *_bonus if present ---
  try{
    const attrs=['flair','simple','elegant','lively','chic','cute','sexy','pure','cool','warm'];
    const orig = window.scoreItemForStage;
    if(typeof orig !== "function"){
      window.scoreItemForStage = function(item, stage){
        if(!stage) return 0;
        const factor = (toNum(stage.weight||9))/9;
        const stageW = {...stage};
        attrs.forEach(a => stageW[a] = toNum(stageW[a]||0) * factor);
        let base = 0;
        for(const a of attrs){
          const grade = gradeToScore(item[a]);
          const bonus = toNum(item[`${a}_bonus`]||0);
          base += toNum(stageW[a]) * (grade + bonus);
        }
        return base * starMultiplier(item.stars) * (PART_WEIGHTS[item.part]||1);
      };
    }else{
      window.scoreItemForStage = function(item, stage){
        if(!stage) return 0;
        const factor = (toNum(stage.weight||9))/9;
        const stageW = {...stage};
        attrs.forEach(a => stageW[a] = toNum(stageW[a]||0) * factor);
        let base = 0;
        for(const a of attrs){
          const grade = gradeToScore(item[a]);
          const bonus = toNum(item[`${a}_bonus`]||0);
          base += toNum(stageW[a]) * (grade + bonus);
        }
        return base * starMultiplier(item.stars) * (PART_WEIGHTS[item.part]||1);
      };
    }
  }catch(e){ console.warn("score patch failed:", e); }
})();
</script>
<script>
/* Global de-duplication by (part + normalized name).
   Name normalization removes spaces/punct and common particles (의/와/과) to catch variants like '소녀의고양이' vs '소녀와 고양이'. */
(function(){
  const arr = (window.items || window.ITEMS || []);
  const normName = (s)=> String(s||"")
    .replace(/[ \t\r\n._-]+/g,"")
    .replace(/[의와과]/g,"") // drop common particles
    .toLowerCase();
  const key = (it)=> String(it.part||"").trim()+"@@"+normName(it.name);
  const best = new Map();
  const merge = (a,b)=>{
    const out = {...a};
    const fields = ["stars","img","tags","flair","simple","elegant","lively","chic","cute","sexy","pure","cool","warm","name","part"];
    const bonuses = ["flair_bonus","simple_bonus","elegant_bonus","lively_bonus","chic_bonus","cute_bonus","sexy_bonus","pure_bonus","cool_bonus","warm_bonus"];
    const isEmpty = (v)=> v==null || String(v).trim()==="" || String(v).trim()==="-";
    // prefer non-empty image
    if(isEmpty(out.img) && !isEmpty(b.img)) out.img = b.img;
    // fill empties
    for(const f of fields){
      if(isEmpty(out[f]) && !isEmpty(b[f])) out[f]=b[f];
    }
    // bonuses: prefer numeric; if both numeric, take larger absolute value
    for(const f of bonuses){
      const av = Number(out[f]);
      const bv = Number(b[f]);
      if(Number.isFinite(bv)){
        if(!Number.isFinite(av) || Math.abs(bv)>Math.abs(av)) out[f]=bv;
      }
    }
    return out;
  };
  for(const it of arr){
    const k = key(it);
    if(!best.has(k)) best.set(k, it);
    else best.set(k, merge(best.get(k), it));
  }
  // Replace items with merged unique list
  const unique = Array.from(best.values());
  window.items = unique;
})();
</script>
<!-- Owned items fix: parse/apply/save/load -->
<script>
(function(){
  const OWNED_KEY = window.OWNED_KEY || 'nikki_owned_names';
  const $ = (id)=> document.getElementById(id);

  // Robust split: commas/semicolons/newlines or 2+ spaces separate names.
  function parseOwned(text){
    return String(text||'')
      .split(/[\n\r;,]+|\s{2,}/g)
      .map(s=>s.trim())
      .filter(Boolean);
  }
const normName = (s)=> String(s||'').normalize('NFKC').toLowerCase().replace(/\s+/g,'');
      });
    }
    if(saveBtn){
      saveBtn.addEventListener('click', ()=>{
        saveOwned();
        const t = document.getElementById('toast'); if(t){ t.textContent = '로컬 저장 완료'; t.classList.add('show'); setTimeout(()=> t.classList.remove('show'), 1000); }
      });
    }
    if(clearBtn){
      clearBtn.addEventListener('click', ()=>{
        setOwned([]);
        if(ta) ta.value = '';
        try{ localStorage.removeItem(OWNED_KEY); }catch(e){}
        if(typeof window.renderAll === 'function') window.renderAll();
        const t = document.getElementById('toast'); if(t){ t.textContent = '보유 초기화'; t.classList.add('show'); setTimeout(()=> t.classList.remove('show'), 1000); }
      });
    }
  }

  // Load after the original init, then re-render so badges reflect owned state.
  document.addEventListener('DOMContentLoaded', ()=>{
    loadOwned();
    bindOwnedUI();
    if(typeof window.renderAll === 'function') window.renderAll();
  });
})();
</script>
<!-- De-dup & image fallback patch -->
<script>
(function(){
  const norm = (s)=> String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim();

  function dedupItems(){
    if(!Array.isArray(window.ITEMS)) return {removed:0};
    const seen = new Set();
    const out = [];
    let removed = 0;
    for(const it of window.ITEMS){
      const key = norm(it && it.name);
      if(!key){ out.push(it); continue; }
      if(seen.has(key)){ removed++; continue; }
      seen.add(key);
      out.push(it);
    }
    if(removed > 0){
      window.ITEMS = out;
    }
    return {removed};
  }

  // Global image onerror fallback for Google Drive thumbs
  function attachImgFallback(){
    document.addEventListener('error', function(e){
      const el = e.target;
      if(!(el && el.tagName === 'IMG')) return;
      try{
        const u = new URL(el.src);
        if(u.hostname === 'drive.google.com' && u.pathname === '/thumbnail'){
          const id = u.searchParams.get('id');
          if(id && !el.dataset.fallbackTried){
            el.dataset.fallbackTried = '1';
            el.src = 'https://drive.google.com/uc?export=view&id=' + id;
          }
        }
      }catch(err){ /* ignore */ }
    }, true);
  }

  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};
    const {removed} = dedupItems();
    attachImgFallback();
    if(typeof window.renderAll === 'function'){
      window.renderAll();
    }
    if(removed){
      const t = document.getElementById('toast'); 
      if(t){ t.textContent = `중복 제거: ${removed}개`; t.classList.add('show'); setTimeout(()=> t.classList.remove('show'), 1200); }
      console.log('[dedup] removed', removed);
    }
  });
})();
</script>
<!-- Strong DOM dedup + image overrides + renderAll wrapper -->
<script>
(function(){
  const TOAST = ()=> document.getElementById('toast');
  const showToast = (msg)=>{ const t=TOAST(); if(!t) return; t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1200); };

  const NORM = (s)=> String(s||'')
    .toLowerCase()
    .replace(/[\u3000\u00A0\s]+/g,'')   // all spaces
    .replace(/[~!@#$%^&*()\-_=+\[\]{};:'"\\|,<.>/?·・｡、，．]/g,''); // punctuation

  // Known image overrides by visible name => Drive file id
  const IMG_OVERRIDES = {
    "시어썸머":"16h2tV0wFSxU7F4uNePec9l7R2pE2xN-t",
    "씨솔트크림":"1uVgAy0iUKQA5GqVeZa1EdokPnxfqeIPp"
  };

  function findName(el){
    if(!el) return "";
    if(el.dataset && el.dataset.name) return el.dataset.name;
    // common title/name nodes
    let t = el.querySelector('[data-field="name"], .item-name, .card-title, .title, .name, .label');
    if(t && t.textContent) return t.textContent.trim();
    // aria/alt fallbacks
    if(el.getAttribute){
      const a = el.getAttribute('aria-label') || el.getAttribute('title') || "";
      if(a) return a.trim();
    }
    return "";
  }

  function dedupDOM(){
    const cards = Array.from(document.querySelectorAll('[data-item], [data-name], .item-card, .card, li'));
    const seen = new Set();
    let removed = 0;
    for(const el of cards){
      const nm = findName(el);
      if(!nm) continue;
      const key = NORM(nm);
      if(!key) continue;
      if(seen.has(key)){
        el.remove();
        removed++;
      }else{
        seen.add(key);
      }
    }
    if(removed) showToast(`중복 제거: ${removed}개`);
    return removed;
  }

  function fixImages(){
    // Attach global onerror fallback once
    if(!window.__imgFallbackAttached){
      document.addEventListener('error', function(e){
        const el = e.target;
        if(!(el && el.tagName === 'IMG')) return;
        try{
          const u = new URL(el.src);
          if(u.hostname === 'drive.google.com' && u.pathname === '/thumbnail'){
            const id = u.searchParams.get('id');
            if(id && !el.dataset.fallbackTried){
              el.dataset.fallbackTried = '1';
              el.src = 'https://drive.google.com/uc?export=view&id='+id;
            }
          }
        }catch(err){}
      }, true);
      window.__imgFallbackAttached = true;
    }

    // Apply explicit overrides by name
    const all = Array.from(document.querySelectorAll('img'));
    for(const img of all){
      const card = img.closest('[data-item], .item-card, .card, li') || img.parentElement;
      const nm = NORM(findName(card));
      if(IMG_OVERRIDES[nm] && !img.dataset.overrideApplied){
        img.dataset.overrideApplied = '1';
        img.src = 'https://drive.google.com/uc?export=view&id='+IMG_OVERRIDES[nm];
      }
    }
  }

  // Wrap renderAll so dedup & image fixes run after every render
  (function wrapRender(){
    if(typeof window.renderAll === 'function'){
      const orig = window.renderAll;
      window.renderAll = function(){
        const r = orig.apply(this, arguments);
        // run after DOM updates
        queueMicrotask(()=>{ fixImages(); dedupDOM(); });
        return r;
      };
    }
  })();

  // Also run once on initial load and whenever DOM changes (defensive)
  document.addEventListener('DOMContentLoaded', ()=>{
    fixImages();
    dedupDOM();
  });
  const mo = /* MO-off */ (null && new MutationObserver)(()=>{ fixImages(); dedupDOM(); });
  mo.observe(document.documentElement, {childList:true, subtree:true});
})();
</script>
<script>

<script>

<script>


<script>
function toThumb(u){
    try{
      if(!u) return u;
      if(/drive\.google\.com\/thumbnail\?id=/.test(u)) return u;
      var m = String(u).match(/\/d\/([a-zA-Z0-9_-]{10,})\/view/);
      if(m) return "https://drive.google.com/thumbnail?id="+m[1];
      if(/^[a-zA-Z0-9_-]{10,}$/.test(u)) return "https://drive.google.com/thumbnail?id="+u;
    }catch(e){}
    return u;
  }

  var sane = NEW_ITEMS.map(function(it){
    var out = Object.assign({}, it);
    out.img = toThumb(out.img);
    return out;
  });
  if(Array.isArray(window.items)) window.items.push.apply(window.items, sane);
  if(typeof window.renderAll === "function") window.renderAll();
})();

</script>
<script>
(function(){
  var got = {items:false, stages:false};
  function maybeInit(){
    if (got.items && got.stages) {
      if (!window.items) window.items = [];
      if (!window.stages) window.stages = [];
      if (typeof init === 'function') init();
      try{ if(window._loading) window._loading.show(false); }catch(e){}
      try{ if(typeof renderAll==='function') renderAll(); }catch(e){}
    }
  }
  window.addEventListener('message', function(ev){
    var msg = ev.data;
    if (!msg || !msg.__splitData) return;
    if (msg.key==='items'){ window.items = msg.data; got.items = true; try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){} }
    if (msg.key==='stages'){ window.stages = msg.data; got.stages = true; try{ if(typeof __populateStages==='function') __populateStages(); }catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){} }
    maybeInit();
  });
})();
</script>


<script>
(function(){
  var inited = false;
  var origInit = window.init;
  window.init = function(){
    if (typeof origInit === 'function') origInit();
    if (typeof renderPartCounts === 'function') renderPartCounts();
  };
})();
</script>
<script>
(function(){
  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'')
      .split(/[\n\r;,]+|\s{2,}/g)
      .map(s=> s.trim())
      .filter(Boolean);
  }
  function computePerPart(){
    var items = (window.items || window.ITEMS || []);
    var itemByName = Object.create(null);
    for (var it of items){
      var key = window.normOwnedName(it && it.name);
      if (key && !(key in itemByName)) itemByName[key] = it;
    }
    // totals
    var totals = Object.create(null);
    for (var it of items){
      var p = (it && it.part) || '(기타)';
      if (!totals[p]) totals[p] = 0;
      totals[p]++;
    }
    // owned
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    var owned = Object.create(null);
    for (var n of names){
      var it = itemByName[norm(n)];
      if (!it) continue;
      var p = it.part || '(기타)';
      if (!owned[p]) owned[p] = 0;
      owned[p]++;
    }
    // build rows
    var parts = Object.keys(totals).sort();
    var rows = parts.map(function(p){
      var t = totals[p]||0;
      var o = owned[p]||0;
      var rate = t ? ((o*100)/t).toFixed(1) + '%' : '-';
      return { part:p, owned:o, total:t, rate:rate };
    });
    return rows;
  }
  function renderPerPartTable(){
    var tbody = document.querySelector('#partSummaryTable tbody');
    if (!tbody) return;
    var rows = computePerPart();
    tbody.innerHTML = rows.map(function(r){
      return '<tr data-part=\"'+ r.part.replace(/"/g,'&quot;') +'\">'
        + '<td>'+ r.part +'</td>'
        + '<td>'+ r.owned +'</td>'
        + '<td>'+ r.total +'</td>'
        + '<td>'+ r.rate +'</td>'
        + '</tr>';
    }).join('');
  }
  // click -> sync to existing partFilter
  document.addEventListener('click', function(ev){
    var tr = ev.target && ev.target.closest && ev.target.closest('#partSummaryTable tbody tr');
    if (!tr) return;
    var part = tr.getAttribute('data-part') || '';
    var sel = document.getElementById('partFilter');
    if (sel){
      // Try to match exact option; fallback to empty if not found
      var found = false;
      for (var i=0;i<sel.options.length;i++){
        if (sel.options[i].value === part){ sel.selectedIndex = i; found = true; break; }
      }
      if (!found) sel.value = '';
      sel.dispatchEvent(new Event('change', {bubbles:true}));
    }
  }, false);
  // keep table in sync
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){ renderPerPartTable(); }
  });
  var origInit = window.init;
  window.init = function(){
    if (typeof origInit === 'function') origInit();
    renderPerPartTable();
  };
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(renderPerPartTable, 50); });
})();
</script>
<script>
(function(){
  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'')
      .split(/[\n\r;,]+|\s{2,}/g)
      .map(s=> s.trim())
      .filter(Boolean);
  }
  function computePartStats(){
    var items = (window.items || window.ITEMS || []);
    var totals = Object.create(null);
    var byName = Object.create(null);
    for (var it of items){
      var p = it && it.part || '(기타)';
      totals[p] = (totals[p]||0)+1;
      var key = window.normOwnedName(it && it.name);
      if (key && !(key in byName)) byName[key] = it;
    }
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    var ownedPer = Object.create(null);
    var ownedTotal = 0;
    for (var n of names){
      var it = byName[norm(n)];
      if (it){
        var p = it.part || '(기타)';
        ownedPer[p] = (ownedPer[p]||0)+1;
        ownedTotal++;
      }
    }
    var totalCount = (window.items||window.ITEMS||[]).length;
    // Build sorted parts
    var parts = Object.keys(totals).sort();
    return {parts:parts, totals:totals, ownedPer:ownedPer, ownedTotal:ownedTotal, totalCount: totalCount};
  }
  function renderPartBar(){
    var bar = document.getElementById('partBar');
    if (!bar) return;
    var stats = computePartStats();
    // Summary mini
    var mini = document.getElementById('ownedSummaryMini');
    if (mini){ mini.textContent = '보유 ' + stats.ownedTotal + ' / 전체 ' + stats.totalCount; }

    bar.innerHTML = stats.parts.map(function(p){
      var o = stats.ownedPer[p] || 0;
      var t = stats.totals[p] || 0;
      return '<span class="pill-small" data-part="'+ p.replace(/"/g,'&quot;') +'" title="'+ p +'">'
        + '<span class="k">'+ p +'</span>'
        + '<span class="v">'+ o +'/'+ t +'</span>'
        + '</span>';
    }).join('');
  }
  // Click a pill -> sync to existing part filter
  document.addEventListener('click', function(ev){
    var el = ev.target.closest && ev.target.closest('.pill-small');
    if (!el) return;
    var part = el.getAttribute('data-part') || '';
    var sel = document.getElementById('partFilter');
    if (sel){
      var found = false;
      for (var i=0;i<sel.options.length;i++){
        if (sel.options[i].value === part){ sel.selectedIndex = i; found = true; break; }
      }
      if (!found) sel.value = '';
      sel.dispatchEvent(new Event('change', {bubbles:true}));
    }
  }, false);
  // Toggle collapse (single line vs hidden)
  document.addEventListener('click', function(ev){
    if (ev.target && ev.target.id === 'togglePartBar'){
      var bar = document.getElementById('partBar');
      if (!bar) return;
      var isHidden = bar.style.display === 'none';
      bar.style.display = isHidden ? 'flex' : 'none';
      ev.target.textContent = isHidden ? '접기' : '펼치기';
    }
  });
  // Update on input & after init
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){ renderPartBar(); }
  });
  var origInit = window.init;
  window.init = function(){
    if (typeof origInit === 'function') origInit();
    renderPartBar();
  };
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(renderPartBar, 50); });
})();
</script>
<script>
(function(){
  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'')
      .split(/[\n\r;,]+|\s{2,}/g)
      .map(s=> s.trim())
      .filter(Boolean);
  }
  function computeStats(){
    var items = (window.items || window.ITEMS || []);
    var totals = {}, byName={};
    for (var it of items){
      var p = it && it.part || '(기타)';
      totals[p] = (totals[p]||0)+1;
      var key = window.normOwnedName(it && it.name);
      if (key && !(key in byName)) byName[key] = it;
    }
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    var ownedPer = {}, ownedTotal = 0;
    for (var n of names){
      var it = byName[norm(n)];
      if (it){
        var p = it.part || '(기타)';
        ownedPer[p] = (ownedPer[p]||0)+1;
        ownedTotal++;
      }
    }
    return {totals:totals, ownedPer:ownedPer, ownedTotal:ownedTotal, totalCount:items.length};
  }
  function renderPartBar(){
    var stats = computeStats();
    var mini = document.getElementById('ownedSummaryMini');
    if (mini){ mini.textContent = '보유 ' + stats.ownedTotal + ' / 전체 ' + stats.totalCount; }
    var bar = document.getElementById('partBar');
    if (!bar) return;
    var parts = [];
    var sel = document.getElementById('partFilter');
    if (sel){
      for (var i=0;i<sel.options.length;i++){
        var v = sel.options[i].value;
        if (!v) continue; // skip 전체
        parts.push(v);
      }
    } else {
      parts = Object.keys(stats.totals).sort();
    }
    bar.innerHTML = parts.map(function(p){
      var o = stats.ownedPer[p]||0;
      var t = stats.totals[p]||0;
      return '<span class="pill-small" data-part="'+ p.replace(/"/g,'&quot;') +'">'
        + '<span class="k">'+ p +'</span>'
        + '<span class="v">'+ o +'/'+ t +'</span>'
        + '</span>';
    }).join('');
  }
  window.renderPartBar = renderPartBar;
  // Hook to init
  var origInit = window.init;
  window.init = function(){
    if (typeof origInit === 'function') origInit();
    renderPartBar();
  };
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(renderPartBar,50); });
  document.addEventListener('input', function(ev){ if(ev.target && ev.target.id==='ownedInput') renderPartBar(); });
})();
</script>
<script>
(function(){
  var ORDER_WEAR = ["헤어 스타일","원피스","아우터","상의","하의","양말","신발"];
  var ORDER_ACC = ["모자","헤어 장식","얼굴 장식","귀걸이","목걸이","손목 장식","장갑","반지","소지품","날개","꼬리","등 장식","발찌","크로스백","블로팅","타투","탑승물"];
  var ORDER_MAKEUP = ["아이브로우","컬러 렌즈","아이라이너","아이섀도우","립 메이크업","속눈썹","블러셔","페이스 타투"];
  var GROUPS = { wear: ORDER_WEAR, acc: ORDER_ACC, makeup: ORDER_MAKEUP };

  function norm(s){ return String(s||'').toLowerCase().replace(/[\\s\\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'').split(/[\\n\\r;,]+|\\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
  }
  function getStats(){
    var items = (window.items || window.ITEMS || []);
    var totals = Object.create(null);
    var byName = Object.create(null);
    for (var i=0;i<items.length;i++){
      var it = items[i];
      var p = (it && it.part) || '';
      totals[p] = (totals[p]||0)+1;
      var key = window.normOwnedName(it && it.name);
      if (key && !(key in byName)) byName[key] = it;
    }
    var ownedPer = Object.create(null);
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    for (var j=0;j<names.length;j++){
      var it2 = byName[window.normOwnedName(names[j])];
      if (!it2) continue;
      var pp = it2.part || '';
      ownedPer[pp] = (ownedPer[pp]||0)+1;
    }
    return {totals: totals, ownedPer: ownedPer};
  }
  function pill(part, o, t){
    return '<span class="chip" data-part="'+ part.replace(/"/g,'&quot;') +'" title="'+ part +'"><span class="k">'+ part +'</span><span class="v">'+ (o||0) +'/'+ (t||0) +'</span></span>';
  }
  function renderChips(groupKey){
    var row = document.getElementById('partChips');
    if (!row) return;
    var stats = getStats();
    var order = GROUPS[groupKey] || [];
    row.innerHTML = order.map(function(p){
      var o = stats.ownedPer[p] || 0;
      var t = stats.totals[p] || 0;
      return pill(p, o, t);
    }).join('');
  }
  function setGroup(g){
    // toggle button state
    var tabs = document.querySelectorAll('#partTabs .gtab');
    tabs.forEach(function(b){ b.classList.toggle('is-on', b.getAttribute('data-g')===g); });
    renderChips(g);
  }

  // Events
  document.addEventListener('click', function(ev){
    var t = ev.target.closest && ev.target.closest('#partTabs .gtab');
    if (t){
      setGroup(t.getAttribute('data-g'));
      return;
    }
    var chip = ev.target.closest && ev.target.closest('#partChips .chip');
    if (chip){
      var part = chip.getAttribute('data-part') || '';
      var sel = document.getElementById('partFilter');
      if (sel){
        var found = false;
        for (var i=0;i<sel.options.length;i++){
          if (sel.options[i].value === part){ sel.selectedIndex = i; found = true; break; }
        }
        if (!found) sel.value = '';
        sel.dispatchEvent(new Event('change', {bubbles:true}));
      }
    }
  }, false);

  // Update chips on owned input change
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      setGroup(on ? on.getAttribute('data-g') : 'wear');
    }
  });

  // Hook into init
  var origInit = window.init;
  window.init = function(){
    if (typeof origInit === 'function') origInit();
    setGroup('wear'); // default group
  };
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(function(){ setGroup('wear'); }, 50); });
})();
</script>
<script>
(function(){
  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'').split(/[\n\r;,]+|\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
  }
  function computeOwnedTotal(){
    var items = (window.items || window.ITEMS || []);
    var total = items.length || 0;
    var byName = Object.create(null);
    for (var i=0;i<items.length;i++){
      var it = items[i];
      var key = window.normOwnedName(it && it.name);
      if (key && !(key in byName)) byName[key] = true;
    }
    var ta = document.getElementById('ownedInput');
    var names = ta ? Array.from(new Set(parseOwned(ta.value))) : [];
    var owned = 0;
    for (var j=0;j<names.length;j++){
      if (byName[window.normOwnedName(names[j])]) owned++;
    }
    return {owned: owned, total: total};
  }
  function updateOwnedBadges(){
    var c = computeOwnedTotal();
    var el1 = document.getElementById('ownedSummary');
    var el2 = document.getElementById('ownedSummaryMini');
    if (el1) el1.textContent = '보유 ' + c.owned + ' / 전체 ' + c.total;
    if (el2) el2.textContent = '보유 ' + c.owned + ' / 전체 ' + c.total;
  }
  // hook: after init (data loaded)
  var __origInit = window.init;
  window.init = function(){
    if (typeof __origInit === 'function') __origInit();
    updateOwnedBadges();
  };
  // live update on input changes
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput') updateOwnedBadges();
  });
  // fallback on DOM ready
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(updateOwnedBadges, 100); });
  window.updateOwnedBadges = updateOwnedBadges;
})();
</script>
<script>
(function(){
  function markPartHeaders(){
    var sel = document.getElementById('partFilter');
    if (!sel) return;
    var headers = new Set(['팔찌','등 장식','특수 아이템']);
    for (var i=0;i<sel.options.length;i++){
      var opt = sel.options[i];
      if (headers.has(opt.text.trim())){
        opt.disabled = true;            // 선택 불가
        opt.classList.add('groupHdr');  // 진하게(볼드)
      }
    }
    // 만약 현재 선택이 헤더라면 전체로 초기화
    if (sel.selectedIndex >= 0 && sel.options[sel.selectedIndex].disabled){
      sel.value = '';
      sel.dispatchEvent(new Event('change', {bubbles:true}));
    }
  }
  // run after init and on DOM ready
  var __origInit_headers = window.init;
  window.init = function(){
    if (typeof __origInit_headers === 'function') __origInit_headers();
    markPartHeaders();
  };
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(markPartHeaders, 50); });
  window.markPartHeaders = markPartHeaders;
})();
</script>
<script>
(function(){
  var ORDER_WEAR = ["헤어 스타일","원피스","아우터","상의","하의","양말","신발"];
  var ACC_SINGLES = ["모자","헤어 장식","얼굴 장식","귀걸이","목걸이","소지품","탑승물"];
  var ACC_PALJJI = ["손목 장식","장갑","반지"];
  var ACC_BACK   = ["날개","꼬리","등 장식"];
  var ACC_SPEC   = ["발찌","크로스백","블로팅","타투"];
  var ORDER_MAKEUP = ["아이브로우","컬러 렌즈","아이라이너","아이섀도우","립 메이크업","속눈썹","블러셔","페이스 타투"];

  function norm(s){ return String(s||'').toLowerCase().replace(/[\\s\\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'').split(/[\\n\\r;,]+|\\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
  }
  function getStats(){
    var items = (window.items || window.ITEMS || []);
    var totals = Object.create(null);
    var byName = Object.create(null);
    for (var i=0;i<items.length;i++){
      var it = items[i];
      var p = (it && it.part) || '';
      totals[p] = (totals[p]||0)+1;
      var key = window.normOwnedName(it && it.name);
      if (key && !(key in byName)) byName[key] = it;
    }
    var ownedPer = Object.create(null);
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    for (var j=0;j<names.length;j++){
      var it2 = byName[window.normOwnedName(names[j])];
      if (!it2) continue;
      var pp = it2.part || '';
      ownedPer[pp] = (ownedPer[pp]||0)+1;
    }
    return {totals: totals, ownedPer: ownedPer};
  }
  function sumCounts(keys, map){
    var s = 0;
    for (var i=0;i<keys.length;i++){
      s += map[keys[i]] || 0;
    }
    return s;
  }
  function chipHtml(label, owned, total, partValue){
    var pv = partValue || '';
    return '<span class="chip" data-part="'+ pv.replace(/"/g,'&quot;') +'">'
         +   '<span class="k">'+ label +'</span>'
         +   '<span class="v">'+ owned +'/'+ total +'</span>'
         + '</span>';
  }
  function renderChips_acc(S){
    var html = [];
    // singles
    var singles = ACC_SINGLES;
    for (var i=0;i<singles.length;i++){
      var p = singles[i];
      html.push(chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p));
    }
    // subgroups aggregate badges (no click filter for now)
    html.push(chipHtml("팔찌",        sumCounts(ACC_PALJJI, S.ownedPer), sumCounts(ACC_PALJJI, S.totals), ""));
    html.push(chipHtml("등 장식",     sumCounts(ACC_BACK,   S.ownedPer), sumCounts(ACC_BACK,   S.totals), ""));
    html.push(chipHtml("특수 아이템", sumCounts(ACC_SPEC,   S.ownedPer), sumCounts(ACC_SPEC,   S.totals), ""));
    return html.join('');
  }
  function renderChips(groupKey){
    var row = document.getElementById('partChips'); if (!row) return;
    var S = getStats();
    if (groupKey === 'wear'){
      row.innerHTML = ORDER_WEAR.map(function(p){
        return chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p);
      }).join('');
    } else if (groupKey === 'acc'){
      row.innerHTML = renderChips_acc(S);
    } else if (groupKey === 'makeup'){
      row.innerHTML = ORDER_MAKEUP.map(function(p){
        return chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p);
      }).join('');
    }
  }
  function setGroup(g){
    var tabs = document.querySelectorAll('#partTabs .gtab');
    tabs.forEach(function(b){ b.classList.toggle('is-on', b.getAttribute('data-g')===g); });
    renderChips(g);
  }
  document.addEventListener('click', function(ev){
    var chip = ev.target.closest && ev.target.closest('#partChips .chip');
    if (!chip) return;
    var part = chip.getAttribute('data-part') || '';
    if (!part) return; // aggregated badges do nothing on click
    var sel = document.getElementById('partFilter');
    if (sel){
      var found = false;
      for (var i=0;i<sel.options.length;i++){
        if (sel.options[i].value === part){ sel.selectedIndex = i; found = true; break; }
      }
      if (!found) sel.value = '';
      sel.dispatchEvent(new Event('change', {bubbles:true}));
    }
  }, false);
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      setGroup(on ? on.getAttribute('data-g') : 'wear');
    }
  });
  var __origInit = window.init;
  window.init = function(){
    if (typeof __origInit === 'function') __origInit();
    setGroup('wear');
  };
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(function(){ setGroup('wear'); }, 50); });
})();
</script>
<script>
// --- override for accessory aggregated chips ---
(function(){
  var ORDER_WEAR = ["헤어 스타일","원피스","아우터","상의","하의","양말","신발"];
  var ACC_SINGLES = ["모자","헤어 장식","얼굴 장식","귀걸이","목걸이","소지품","탑승물"];
  var ACC_PALJJI = ["손목 장식","장갑","반지"];
  var ACC_BACK   = ["날개","꼬리","등 장식"];
  var ACC_SPEC   = ["발찌","크로스백","블로팅","타투"];
  var ORDER_MAKEUP = ["아이브로우","컬러 렌즈","아이라이너","아이섀도우","립 메이크업","속눈썹","블러셔","페이스 타투"];

  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'').split(/[\n\r;,]+|\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
  }
  function getStats(){
    var items = (window.items || window.ITEMS || []);
    var totals = Object.create(null);
    var byName = Object.create(null);
    for (var i=0;i<items.length;i++){
      var it = items[i];
      var p = (it && it.part) || '';
      totals[p] = (totals[p]||0)+1;
      var key = window.normOwnedName(it && it.name);
      if (key && !(key in byName)) byName[key] = it;
    }
    var ownedPer = Object.create(null);
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    for (var j=0;j<names.length;j++){
      var it2 = byName[window.normOwnedName(names[j])];
      if (!it2) continue;
      var pp = it2.part || '';
      ownedPer[pp] = (ownedPer[pp]||0)+1;
    }
    return {totals: totals, ownedPer: ownedPer};
  }
  function sumCounts(keys, map){
    var s = 0;
    for (var i=0;i<keys.length;i++) s += map[keys[i]] || 0;
    return s;
  }
  function chipHtml(label, owned, total, partValue){
    var pv = partValue || '';
    return '<span class="chip" data-part="'+ pv.replace(/"/g,'&quot;') +'">'
         +   '<span class="k">'+ label +'</span>'
         +   '<span class="v">'+ owned +'/'+ total +'</span>'
         + '</span>';
  }
  function renderChips2(groupKey){
    var row = document.getElementById('partChips'); if (!row) return;
    var S = getStats();
    var html = [];
    if (groupKey === 'wear'){
      ORDER_WEAR.forEach(function(p){
        html.push(chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p));
      });
    } else if (groupKey === 'acc'){
      ACC_SINGLES.forEach(function(p){
        html.push(chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p));
      });
      html.push(chipHtml("팔찌",        sumCounts(ACC_PALJJI, S.ownedPer), sumCounts(ACC_PALJJI, S.totals), ""));
      html.push(chipHtml("등 장식",     sumCounts(ACC_BACK,   S.ownedPer), sumCounts(ACC_BACK,   S.totals), ""));
      html.push(chipHtml("특수 아이템", sumCounts(ACC_SPEC,   S.ownedPer), sumCounts(ACC_SPEC,   S.totals), ""));
    } else if (groupKey === 'makeup'){
      ORDER_MAKEUP.forEach(function(p){
        html.push(chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p));
      });
    }
    row.innerHTML = html.join('');
  }
  function setGroup2(g){
    var tabs = document.querySelectorAll('#partTabs .gtab');
    tabs.forEach(function(b){ b.classList.toggle('is-on', b.getAttribute('data-g')===g); });
    renderChips2(g);
  }
  // Override globals if any
  window.renderChips = renderChips2;
  window.setGroup = setGroup2;

  // Rebind tab clicks to our setGroup
  document.addEventListener('click', function(ev){
    var t = ev.target.closest && ev.target.closest('#partTabs .gtab');
    if (t){
      setGroup2(t.getAttribute('data-g'));
    }
  });

  // Re-render on owned input
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      setGroup2(on ? on.getAttribute('data-g') : 'wear');
    }
  });

  // Run once after init
  var __origInit2 = window.init;
  window.init = function(){
    if (typeof __origInit2 === 'function') __origInit2();
    setGroup2('wear');
  };
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(function(){ setGroup2('wear'); }, 60); });
})();
</script>
<script>
(function(){
  var ORDER_WEAR = ["헤어 스타일","원피스","아우터","상의","하의","양말","신발"];
  var ACC_SINGLES = ["모자","헤어 장식","얼굴 장식","귀걸이","목걸이","소지품","탑승물"];
  var ACC_PALJJI = ["손목 장식","장갑","반지"];
  var ACC_BACK   = ["날개","꼬리","등 장식"];
  var ACC_SPEC   = ["발찌","크로스백","블로팅","타투"];
  var ORDER_MAKEUP = ["아이브로우","컬러 렌즈","아이라이너","아이섀도우","립 메이크업","속눈썹","블러셔","페이스 타투"];

  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'').split(/[\n\\r;,]+|\\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
  }
  function getStats(){
    var items = (window.items || window.ITEMS || []);
    var totals = Object.create(null);
    var byName = Object.create(null);
    for (var i=0;i<items.length;i++){
      var it = items[i];
      var p = (it && it.part) || '';
      totals[p] = (totals[p]||0)+1;
      var key = window.normOwnedName(it && it.name);
      if (key && !(key in byName)) byName[key] = it;
    }
    var ownedPer = Object.create(null);
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    for (var j=0;j<names.length;j++){
      var it2 = byName[window.normOwnedName(names[j])];
      if (!it2) continue;
      var pp = it2.part || '';
      ownedPer[pp] = (ownedPer[pp]||0)+1;
    }
    return {totals: totals, ownedPer: ownedPer};
  }
  function shortLabel(full){
    var prefixes = ["팔찌 - ", "등 장식 - ", "특수 아이템 - "];
    for (var i=0;i<prefixes.length;i++){
      if (full.indexOf(prefixes[i]) === 0) return full.slice(prefixes[i].length);
    }
    return full;
  }
  function chipHtml(label, owned, total, partValue){
    var pv = partValue || '';
    return '<span class="chip" data-part="'+ pv.replace(/"/g,'&quot;') +'">'
         +   '<span class="k">'+ label +'</span>'
         +   '<span class="v">'+ owned +'/'+ total +'</span>'
         + '</span>';
  }
  function renderChips2(groupKey){
    var row = document.getElementById('partChips'); if (!row) return;
    var S = getStats();
    var html = [];
    if (groupKey === 'wear'){
      ORDER_WEAR.forEach(function(p){
        html.push(chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p));
      });
    } else if (groupKey === 'acc'){
      // Singles
      ACC_SINGLES.forEach(function(p){
        html.push(chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p));
      });
      // Detailed sub-items with short labels (but data-part stays full for filter)
      var all = ACC_PALJJI.concat(ACC_BACK).concat(ACC_SPEC);
      all.forEach(function(full){
        var lbl = shortLabel(full);
        html.push(chipHtml(lbl, S.ownedPer[full]||0, S.totals[full]||0, full));
      });
    } else if (groupKey === 'makeup'){
      ORDER_MAKEUP.forEach(function(p){
        html.push(chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p));
      });
    }
    row.innerHTML = html.join('');
  }
  function setGroup2(g){
    var tabs = document.querySelectorAll('#partTabs .gtab');
    tabs.forEach(function(b){ b.classList.toggle('is-on', b.getAttribute('data-g')===g); });
    renderChips2(g);
  }
  // Override previous globals
  window.renderChips = renderChips2;
  window.setGroup = setGroup2;

  // Tab click
  document.addEventListener('click', function(ev){
    var t = ev.target.closest && ev.target.closest('#partTabs .gtab');
    if (t) setGroup2(t.getAttribute('data-g'));
    var chip = ev.target.closest && ev.target.closest('#partChips .chip');
    if (chip){
      var part = chip.getAttribute('data-part') || '';
      if (!part) return;
      var sel = document.getElementById('partFilter');
      if (sel){
        // match by value (full part); fallback to text
        var found = false;
        for (var i=0;i<sel.options.length;i++){
          var opt = sel.options[i];
          if (opt.value === part || opt.text.trim() === part){
            sel.selectedIndex = i; found = true; break;
          }
        }
        if (!found) sel.value = '';
        sel.dispatchEvent(new Event('change', {bubbles:true}));
      }
    }
  });

  // Owned input change -> refresh
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      setGroup2(on ? on.getAttribute('data-g') : 'wear');
    }
  });

  // After init
  var __origInit2 = window.init;
  window.init = function(){
    if (typeof __origInit2 === 'function') __origInit2();
    setGroup2('wear');
  };
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(function(){ setGroup2('wear'); }, 60); });
})();
</script>
<script>
// ---- Robust owned-name -> item.part matching + chip counts refresh ----
(function(){
  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    // 줄바꿈 / 쉼표 / 세미콜론 / 2칸 이상의 공백 구분
    return String(text||'')
      .split(/[\n\r;,]+|\s{2,}/g)
      .map(function(s){ return s.trim(); })
      .filter(Boolean);
  }

  // Map owned names (입력란) -> item.part 카운트
  function getStatsOwnedAware(){
    var items = (window.items || window.ITEMS || []);
    var totals = Object.create(null);
    var byName = Object.create(null);
    for (var i=0;i<items.length;i++){
      var it = items[i]; if (!it) continue;
      var p = it.part || '';
      totals[p] = (totals[p]||0) + 1;
      var key = window.normOwnedName(it.name);
      if (key && !(key in byName)) byName[key] = it;
    }
    var ownedPer = Object.create(null);
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    for (var j=0;j<names.length;j++){
      var it2 = byName[window.normOwnedName(names[j])];
      if (!it2) continue; // 입력한 이름이 데이터에 없으면 무시
      var pp = it2.part || '';
      ownedPer[pp] = (ownedPer[pp]||0) + 1;
    }
    return { totals: totals, ownedPer: ownedPer };
  }

  // Helper: prefix 제거한 짧은 라벨
  function shortLabel(full){
    var prefixes = ["팔찌 - ", "등 장식 - ", "특수 아이템 - "];
    for (var i=0;i<prefixes.length;i++){
      if (full.indexOf(prefixes[i]) === 0) return full.slice(prefixes[i].length);
    }
    return full;
  }

  // Accessory lists
  var ORDER_WEAR   = ["헤어 스타일","원피스","아우터","상의","하의","양말","신발"];
  var ACC_SINGLES  = ["모자","헤어 장식","얼굴 장식","귀걸이","목걸이","소지품","탑승물"];
  var ACC_PALJJI   = ["손목 장식","장갑","반지"];
  var ACC_BACK     = ["날개","꼬리","등 장식"];
  var ACC_SPEC     = ["발찌","크로스백","블로팅","타투"];
  var ORDER_MAKEUP = ["아이브로우","컬러 렌즈","아이라이너","아이섀도우","립 메이크업","속눈썹","블러셔","페이스 타투"];

  function chipHtml(label, owned, total, partValue){
    var pv = partValue || '';
    return '<span class="chip" data-part="'+ pv.replace(/"/g,'&quot;') +'">'
         +   '<span class="k">'+ label +'</span>'
         +   '<span class="v">'+ (owned||0) +'/'+ (total||0) +'</span>'
         + '</span>';
  }

  function renderChips_fixed(groupKey){
    var row = document.getElementById('partChips'); if (!row) return;
    var S = getStatsOwnedAware();
    var html = [];
    if (groupKey === 'wear'){
      ORDER_WEAR.forEach(function(p){
        html.push(chipHtml(p, S.ownedPer[p], S.totals[p], p));
      });
    } else if (groupKey === 'acc'){
      // 개별 액세서리 (그룹 접두사 없는 항목)
      ACC_SINGLES.forEach(function(p){
        html.push(chipHtml(p, S.ownedPer[p], S.totals[p], p));
      });
      // 소그룹 세부 항목들 - 라벨은 짧게, 값은 풀네임
      ACC_PALJJI.concat(ACC_BACK).concat(ACC_SPEC).forEach(function(full){
        html.push(chipHtml(shortLabel(full), S.ownedPer[full], S.totals[full], full));
      });
    } else if (groupKey === 'makeup'){
      ORDER_MAKEUP.forEach(function(p){
        html.push(chipHtml(p, S.ownedPer[p], S.totals[p], p));
      });
    }
    row.innerHTML = html.join('');
  }

  function setGroup_fixed(g){
    var tabs = document.querySelectorAll('#partTabs .gtab');
    tabs.forEach(function(b){ b.classList.toggle('is-on', b.getAttribute('data-g')===g); });
    renderChips_fixed(g);
  }

  // Override any previous versions
  window.renderChips = renderChips_fixed;
  window.setGroup = setGroup_fixed;

  // Click on chip -> filter by full part (data-part)
  document.addEventListener('click', function(ev){
    var chip = ev.target.closest && ev.target.closest('#partChips .chip');
    if (!chip) return;
    var part = chip.getAttribute('data-part') || '';
    if (!part) return;
    var sel = document.getElementById('partFilter');
    if (sel){
      var found = false;
      for (var i=0;i<sel.options.length;i++){
        var opt = sel.options[i];
        if (String(opt.value).trim() === part){
          sel.selectedIndex = i; found = true; break;
        }
      }
      if (!found) sel.value = '';
      sel.dispatchEvent(new Event('change', {bubbles:true}));
    }
  }, false);

  // Re-render on owned input change
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      setGroup_fixed(on ? on.getAttribute('data-g') : 'wear');
    }
  });

  // Hook into init to ensure counts after data load
  var __orig = window.init;
  window.init = function(){
    if (typeof __orig === 'function') __orig();
    setGroup_fixed('wear');
  };
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(function(){ setGroup_fixed('wear'); }, 80); });
})();
</script>
<script>
// --- Robust data resolver: read items from main or from data iframes ---
(function(){
  function resolveItems(){
    // 1) direct on window
    if (Array.isArray(window.items))  return window.items;
    if (Array.isArray(window.ITEMS))  return window.ITEMS;

    // 2) known iframe by id/name
    var f = document.getElementById('itemsFrame') || document.querySelector('iframe#itemsFrame, iframe[name="itemsFrame"]');
    if (f && f.contentWindow){
      try{
        if (Array.isArray(f.contentWindow.items)) return f.contentWindow.items;
        if (Array.isArray(f.contentWindow.ITEMS)) return f.contentWindow.ITEMS;
      }catch(e){ /* cross-origin or not ready */ }
    }

    // 3) scan any iframe on the page
    var ifs = document.querySelectorAll('iframe');
    for (var i=0;i<ifs.length;i++){
      var cw;
      try{ cw = ifs[i].contentWindow; }catch(e){ continue; }
      if (!cw) continue;
      try{
        if (Array.isArray(cw.items)) return cw.items;
        if (Array.isArray(cw.ITEMS)) return cw.ITEMS;
      }catch(e){ /* ignore */ }
    }
    return null;
  }

  // Expose for other scripts
  window.__resolveItems = resolveItems;

  // Patch getStatsOwnedAware (if defined) to use resolver; otherwise define a safe one.
  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'').split(/[\n\r;,]+|\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
  }

  function getStatsOwnedAwarePatched(){
    var items = resolveItems() || [];
    var totals = Object.create(null);
    var byName = Object.create(null);
    for (var i=0;i<items.length;i++){
      var it = items[i]; if (!it) continue;
      var p = it.part || '';
      totals[p] = (totals[p]||0) + 1;
      var key = window.normOwnedName(it.name);
      if (key && !(key in byName)) byName[key] = it;
    }
    var ownedPer = Object.create(null);
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    for (var j=0;j<names.length;j++){
      var it2 = byName[window.normOwnedName(names[j])];
      if (!it2) continue;
      var pp = it2.part || '';
      ownedPer[pp] = (ownedPer[pp]||0) + 1;
    }
    return { totals: totals, ownedPer: ownedPer };
  }

  // If a previous function exists, overwrite safely
  window.getStatsOwnedAware = getStatsOwnedAwarePatched;

  // When items become available later, re-render chips & badges automatically
  function refreshIfReady(){
    var arr = resolveItems();
    if (arr && arr.length){
      // refresh chips
      var on = document.querySelector('#partTabs .gtab.is-on');
      var g = on ? on.getAttribute('data-g') : 'wear';
      if (typeof window.setGroup === 'function') window.setGroup(g);

      // refresh owned badges if helpers exist
      if (typeof window.updateOwnedBadges === 'function') window.updateOwnedBadges();
      return true;
    }
    return false;
  }

  // Poll until items are ready (max ~10s)
  var tries = 0;
  var timer = setInterval(function(){
    tries++;
    if (refreshIfReady() || tries > 100){ clearInterval(timer); }
  }, 100);

  // Also listen for iframe load events
  document.addEventListener('load', function(e){
    if (e.target && e.target.tagName === 'IFRAME'){
      setTimeout(refreshIfReady, 50);
    }
  }, true);
})();
</script>
<style>
.badge.owned{display:inline-block;margin-left:6px;padding:2px 6px;border-radius:6px;background:#4caf50;color:#fff;font-size:11px;}
</style>
<script>
(function(){
  function normName(s){
    if (typeof window.normOwnedName === 'function') return window.normOwnedName(s);
    return String(s||'').normalize('NFKC').replace(/\s+/gu,' ').trim().toLowerCase();
  }
  function parseOwnedRaw(text){
    return String(text||'').split(/[\n\r;,]+|\s{2,}/g).map(s=>s.trim()).filter(Boolean);
  }
  function computeOwnedSet(){
    var ta = document.getElementById('ownedInput');
    if (!ta) return null;
    var names = Array.from(new Set(parseOwnedRaw(ta.value))).map(normName);
    window.ownedNameSet = window.ownedNameSet || new Set();
    // reset
    window.ownedNameSet.clear();
    names.forEach(n => window.ownedNameSet.add(n));
    // expose for other code that closed over old reference
    window.__ownedNamesArray = names;
    return window.ownedNameSet;
  }
  function refreshAll(){
    // refresh chips
    var on = document.querySelector('#partTabs .gtab.is-on');
    var g = on ? on.getAttribute('data-g') : 'wear';
    if (typeof window.setGroup === 'function') window.setGroup(g);
    // refresh table/list view if available
    if (typeof window.renderTable === 'function') window.renderTable();
    if (typeof window.render === 'function') window.render();
    if (typeof window.updateOwnedBadges === 'function') window.updateOwnedBadges();
  }
  // Wire input live update
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      computeOwnedSet();
      refreshAll();
    }
  });
  // Buttons
  var applyBtn = document.getElementById('applyOwned');
  if (applyBtn){
    applyBtn.addEventListener('click', function(){
      computeOwnedSet();
      refreshAll();
    });
  }
  var clearBtn = document.getElementById('clearOwned');
  if (clearBtn){
    clearBtn.addEventListener('click', function(){
      var ta = document.getElementById('ownedInput');
      if (ta) ta.value = '';
      computeOwnedSet();
      refreshAll();
    });
  }
  // Init
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};
    computeOwnedSet();
    setTimeout(refreshAll, 60);
  });
})();
</script>
<script>
// --- Auto save & load owned list to localStorage (silent) ---
(function(){
  var LS_KEY = 'nikki_owned_names_v2';

  function safeGet(){
    try { return localStorage.getItem(LS_KEY) || ''; } catch(e){ return ''; }
  }
  function safeSet(v){
    try { localStorage.setItem(LS_KEY, String(v||'')); } catch(e){ /* ignore */ }
  }
  function refreshAll(){
    if (typeof window.setGroup === 'function'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      var g = on ? on.getAttribute('data-g') : 'wear';
      window.setGroup(g);
    }
    if (typeof window.renderTable === 'function') window.renderTable();
    if (typeof window.render === 'function') window.render();
    if (typeof window.updateOwnedBadges === 'function') window.updateOwnedBadges();
  }

  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};
    var ta = document.getElementById('ownedInput');
    if (!ta) return;
    var saved = safeGet();
    if (saved && !ta.value){
      ta.value = saved;
      // trigger existing input handlers to recompute owned set
      ta.dispatchEvent(new Event('input', {bubbles:true}));
      setTimeout(refreshAll, 50);
    }
  });

  var saveTimer = null;
  document.addEventListener('input', function(ev){
    if (!ev.target || ev.target.id !== 'ownedInput') return;
    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(function(){ safeSet(ev.target.value); }, 150);
  });
})();
</script>
<script>
// --- Internal persistent owned-set (independent from textarea) ---
(function(){
  var LS_SET = 'nikki_owned_set_v1';
  var LS_DRAFT = 'nikki_owned_draft_v1';

  function norm(s){
    try { return String(s||'').normalize('NFKC').replace(/\s+/gu,' ').trim().toLowerCase(); }
    catch(e){ return String(s||'').toLowerCase().trim(); }
  }
  function parseList(text){
    return String(text||'').split(/[\n\r;,]+|\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
  }
  function safeGet(k, d){ try{ return localStorage.getItem(k); }catch(e){ return d; } }
  function safeSet(k, v){ try{ localStorage.setItem(k, v); }catch(e){} }

  function refreshAll(){
    if (typeof window.setGroup === 'function'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      var g = on ? on.getAttribute('data-g') : 'wear';
      window.setGroup(g);
    }
    if (typeof window.renderTable === 'function') window.renderTable();
    if (typeof window.render === 'function') window.render();
    if (typeof window.updateOwnedBadges === 'function') window.updateOwnedBadges();
  }

  function loadOwnedSet(){
    var saved = safeGet(LS_SET, '') || '';
    var arr = saved ? saved.split('\n').map(function(s){return s.trim();}).filter(Boolean) : [];
    var set = new Set(arr.map(norm));
    // expose as canonical set used by filters/renderers
    window.ownedNameSet = set;
    window.__ownedNamesArray = Array.from(set);
    return set;
  }

  function saveOwnedSetFromTextarea(){
    var ta = document.getElementById('ownedInput');
    if (!ta) return;
    var names = parseList(ta.value);
    var normed = Array.from(new Set(names.map(norm)));
    safeSet(LS_SET, normed.join('\n'));
    loadOwnedSet();
    refreshAll();
  }

  // Override any earlier computeOwnedSet so typing doesn't clear the set
  window.computeOwnedSet = function(commit){
    if (commit) saveOwnedSetFromTextarea();
    // else: ignore live typing
  };

  // Apply button commits textarea -> internal set
  document.addEventListener('click', function(ev){
    var t = ev.target && ev.target.closest && ev.target.closest('#applyOwned');
    if (t){ saveOwnedSetFromTextarea(); }
  }, true);

  // Save draft only (doesn't affect owned set)
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      safeSet(LS_DRAFT, ev.target.value);
      // DO NOT touch window.ownedNameSet here
    }
  });

  // Initialize on load: load set from LS, but do NOT auto-fill textarea
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};
    loadOwnedSet();
    setTimeout(refreshAll, 80);
  });
})();
</script>
<script>
(function(){
  function normNewlines(s){ return String(s||'').replace(/\r\n/g,'\n').replace(/\r/g,'\n'); }
  function getOwnedText(){
    var ta = document.getElementById('ownedInput');
    var text = ta ? ta.value : '';
    if (text && text.trim()) return normNewlines(text.trim());
    var set = (window.ownedNameSet instanceof Set) ? Array.from(window.ownedNameSet) : [];
    return set.join('\n');
  }
  function downloadTxt(filename, text){
    var blob = new Blob([text], {type:'text/plain;charset=utf-8'});
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click();
    setTimeout(function(){ URL.revokeObjectURL(url); a.remove(); }, 0);
  }
  function refreshAll(){
    // chips/tabs
    if (typeof window.setGroup === 'function'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      var g = on ? on.getAttribute('data-g') : 'wear';
      window.setGroup(g);
    }
    // lists/tables if present
    if (typeof window.renderTable === 'function') window.renderTable();
    if (typeof window.render === 'function') window.render();
    if (typeof window.updateOwnedBadges === 'function') window.updateOwnedBadges();
  }
  function applyFromTextarea(){
    var ta = document.getElementById('ownedInput');
    if (!ta) return;
    // trigger any existing listeners that build owned set
    ta.dispatchEvent(new Event('input', {bubbles:true}));
    if (typeof window.computeOwnedSet === 'function') window.computeOwnedSet(true);
    refreshAll();
  }
  function handleFile(file){
    var reader = new FileReader();
    reader.onload = function(ev){
      var text = normNewlines(ev.target.result);
      var ta = document.getElementById('ownedInput');
      if (ta){ ta.value = text; }
      // 바로 적용
      applyFromTextarea();
    };
    reader.readAsText(file, 'utf-8');
  }

  document.addEventListener('click', function(ev){
    var id = ev.target && ev.target.id;
    if (id === 'exportOwned'){
      var text = getOwnedText();
      if (!text){ alert('보유 의상 목록이 비어 있습니다.'); return; }
      downloadTxt('owned_items.txt', text);
    } else if (id === 'importOwned'){
      var inp = document.getElementById('importOwnedFile');
      if (inp) inp.click();
    }
  });
  document.addEventListener('change', function(ev){
    if (ev.target && ev.target.id === 'importOwnedFile' && ev.target.files.length){
      handleFile(ev.target.files[0]);
      ev.target.value = '';
    }
  });
})();
</script>
<footer id="metaFooter" style="margin:24px 0 0; padding:12px; text-align:center; color:#666; font-size:12px; ">
  제작자 : 윤드 · 
</footer>
<script>
// --- Stage-defined extra attributes (no UI) ---
// Expect each stage object can define:
//   extras: ["활발","심플","청량"]         // up to any number
//   extras_pct: 5                         // percent as number (default 5)
(function(){
  window.__getStageExtraAttrs = function(stage){
    if (!stage) return [];
    if (Array.isArray(stage.extras)) return stage.extras;
    if (Array.isArray(stage.extraAttrs)) return stage.extraAttrs;
    return [];
  };
  window.__getStageExtraPct = function(stage){
    if (!stage) return 0.05;
    var p = (typeof stage.extras_pct === 'number') ? stage.extras_pct :
            (typeof stage.extras_pct === 'string' ? (+stage.extras_pct) : NaN);
    if (!isNaN(p) && p > 0) return p / 100;
    return 0.05; // default 5%
  };
})();
</script>
<script>
(function(){
  function moveRequiredFirst(){
    try{
      const tips = document.getElementById('tips');
      if(!tips) return;
      const req = tips.querySelector('.reqlist');
      if(req && tips.firstChild !== req){
        tips/* disabled tips reorder */ void 0;
      }
    }catch(e){}
  }
  function hideStyleRatio(){
    const tips = document.getElementById('tips');
    if(!tips) return;
    const kids = Array.from(tips.children);
    const m=/메인\s*[^,%]+?\d+%/; const s=/서브\s*[^,%]+?\d+%/; const t=/태그\s*[^,%]+?\d+%/;
    kids.forEach(el=>{
      const tx=(el.textContent||'').replace(/\s+/g,' ').trim();
      const c=[m.test(tx),s.test(tx),t.test(tx)].filter(Boolean).length;
      if((c>=2&&tx.length<=120)||(/^메인\s*[^,%]+?\d+%/.test(tx)&&tx.length<=80)){ el.style.display='none'; }
    });
  }
  function postRender(){
    hideStyleRatio();
    moveRequiredFirst();
  }
  function ensureStagesSynced(){
    var tries=0, max=64; var timer=setInterval(function(){ tries++;
      var sf = document.getElementById('stagesFrame');
      var ifw = sf && sf.contentWindow;
      var iframeStages = (ifw && ifw.stages) || null;
      var parentStages = window.stages || null;
      // If iframe has stages but parent doesn't, copy
      if(iframeStages && Array.isArray(iframeStages) && iframeStages.length){
        if(!parentStages || !Array.isArray(parentStages) || parentStages.length < iframeStages.length){
          try{ window.stages = JSON.parse(JSON.stringify(iframeStages)); }catch(e){ window.stages = iframeStages; }
          // Trigger renderAll if available
          try{ if(typeof window.__populateStages==='function'){ window.__populateStages(); }
          if(typeof window.renderAll==='function'){ window.renderAll(); } }catch(e){}
          // Also try to dispatch change on stageSelect
          var sel = document.getElementById('stageSelect');
          if(sel){
            var ev = new Event('change', {bubbles:true});
            sel.dispatchEvent(ev);
          }
          // After syncing, run postRender
          setTimeout(postRender, 0);
        }
      }
      if(tries>=max || (window.stages && Array.isArray(window.stages) && window.stages.length>0)){
        clearInterval(timer);
        setTimeout(postRender, 0);
      }
    },125);
  }
  window.addEventListener('load', function(){
    // Guard: both iframes should exist
    var s = document.querySelector('iframe[src$="stages_frame_v2.html"]');
    var i = document.querySelector('iframe[src$="items_frame_v2.html"]');
    if(!s || !i){ console.warn('[fix] expected stages/items iframes not found'); }
    ensureStagesSynced();
    // Observe tips only (non-intrusive)
    const tips = document.getElementById('tips');
    if(tips){
      const mo = /* MO-off */ (null && new MutationObserver)(postRender);
      mo.observe(tips, {childList:true, subtree:true});
document.addEventListener('DOMContentLoaded', function(){
    // Guard: both iframes should exist
    var s = document.querySelector('iframe[src$="stages_frame_v2.html"]');
    var i = document.querySelector('iframe[src$="items_frame_v2.html"]');
    if(!s || !i){ console.warn('[fix] expected stages/items iframes not found'); }
    ensureStagesSynced();
    // Observe tips only (non-intrusive)
    const tips = document.getElementById('tips');
    if(tips){
      const mo = /* MO-off */ (null && new MutationObserver)(postRender);
      mo.observe(tips, {childList:true, subtree:true});
    }
  });
})();
</script>
<script>
(function(){
  // Safe helpers
  const ownNorm = window.normOwnedName || (s=> String(s||'').toLowerCase().replace(/\s+/g,''));

  function getSelectedStage(){
    const sel = document.getElementById('stageSelect');
    const id = sel && sel.value;
    const s = (window.stages||[]).find(x=> x.stage_id === id) || (window.stages||[])[0];
    return s || null;
  }
  function getRequiredMap(stage){
    const m = {};
    if(stage && stage.required_parts){
      try{
        const rp = stage.required_parts;
        Object.keys(rp).forEach(part=>{
          const arr = Array.isArray(rp[part]) ? rp[part] : [rp[part]];
          m[part] = arr.filter(Boolean);
        });
      }catch(e){}
    }
    return m;
  }
  function updateRequiredPanel(stage, reqMap){
    const tips = document.getElementById('tips');
    if(!tips) return;
    const ownedSet = window.ownedNameSet || new Set();
    const list = Object.keys(reqMap).map(part=>{
      const names = (reqMap[part]||[]).map(name=>{
        const owned = ownedSet.has(ownNorm(name));
        const cls = owned ? 'own' : 'miss';
        const icon = owned ? '✔' : '✖';
        return `<span class="pill ${cls}" title="${owned?'보유':'미보유'}">${icon} ${name}</span>`;
      }).join(' ');
      return `<div class="row" style="gap:8px;align-items:center"><span class="part">${part}</span>${names}</div>`;
    }).join('');
    const requiredBlock = Object.keys(reqMap).length ? `<div class="reqlist"><div class="muted" style="margin-bottom:4px">필수 아이템</div>${list}</div>` : '';
    // Put required items FIRST
    // Preserve existing tips content by appending after requiredBlock
    const old = tips.innerHTML;
    tips.innerHTML = requiredBlock + old;
    // Ensure it's at the top even if render re-writes tips later
    const req = tips.querySelector('.reqlist');
    if(req && tips.firstChild !== req){
      tips/* disabled tips reorder */ void 0;
    }
  }
  function addBadgesToCards(stage, reqMap){
    const reqNames = new Set();
    Object.values(reqMap).forEach(arr=> (arr||[]).forEach(n=> reqNames.add(ownNorm(n))));
    const cards = document.querySelectorAll('#list .card');
    cards.forEach(card=>{
      const nameEl = card.querySelector('h3 span');
      const badges = card.querySelector('.badges');
      if(!nameEl || !badges) return;
      const nm = ownNorm(nameEl.textContent||'');
      if(reqNames.has(nm)){
        if(!badges.querySelector('.badge.req')){
          const el = document.createElement('span');
          el.className = 'badge req';
          el.textContent = '필수';
          badges.appendChild(el);
        }
      }else{
        // remove if previously added and no longer required for new stage
        const b = badges.querySelector('.badge.req');
        if(b) b.remove();
      }
    });
  }
  function runRequiredUI(){
    try{
      const stage = getSelectedStage();
      const reqMap = getRequiredMap(stage);
      // Clear previous checklist to avoid stacking
      const tips = document.getElementById('tips');
      if(tips){
        const oldReq = tips.querySelector('.reqlist');
        if(oldReq) oldReq.remove();
      }
      updateRequiredPanel(stage, reqMap);
      addBadgesToCards(stage, reqMap);
    }catch(e){ /* no-op */ }
  }

  // Run after every render without overriding render functions
  document.addEventListener('DOMContentLoaded', ()=>{
    // Initial try
    setTimeout(runRequiredUI, 0);
    setTimeout(runRequiredUI, 200);
    // Respond to stage change
    document.addEventListener('change', (e)=>{
      if(e.target && e.target.id==='stageSelect'){
        setTimeout(runRequiredUI, 0);
      }
    });
    // Observe list & tips for re-renders
    const list = document.getElementById('list');
    if(list){
      /* MO-off */ (null && new MutationObserver)(()=> runRequiredUI()).observe(list, {childList:true, subtree:true});
    }
    const tips = document.getElementById('tips');
    if(tips){
      /* MO-off */ (null && new MutationObserver)(()=>{
        // keep required block FIRST
        const req = tips.querySelector('.reqlist');
        if(req && tips.firstChild !== req) tips/* disabled tips reorder */ void 0;
      }).observe(tips, {childList:true, subtree:true});
    }
  });
})();
</script>
<script>
(function(){
  // Normalize a value into array of strings
  function toNames(v){
    if (v == null) return [];
    if (Array.isArray(v)) return v.map(String);
    if (typeof v === 'object'){
      // flatten object values (e.g., {name:"X"} or {opt1:"X", opt2:["Y"]})
      const out = [];
      Object.values(v).forEach(val=>{
        if (val == null) return;
        if (Array.isArray(val)) out.push(...val.map(String));
        else out.push(String(val));
      });
      return out;
    }
    return [String(v)];
  }

  const PART_ALLOW = new Set(["헤어","원피스","아우터","상의","하의","양말","신발","액세서리","메이크업","모자","목걸이","귀걸이","팔찌","반지","가방","기타"]);

  const ownNorm = window.normOwnedName || (s=> String(s||'').toLowerCase().replace(/\s+/g,''));

  function getSelectedStage(){
    const sel = document.getElementById('stageSelect');
    const id = sel && sel.value;
    const list = Array.isArray(window.stages) ? window.stages : [];
    return list.find(x=> x && String(x.stage_id)===String(id)) || list[0] || null;
  }
  function buildReqMap(stage){
    const m = {};
    const rp = stage && stage.required_parts ? stage.required_parts : null;
    if(!rp || typeof rp!=="object") return m;
    Object.keys(rp).forEach(key=>{
      if(!key) return;
      // strip obviously wrong keys
      if (key==="required_parts" || key==="_" || key==="required" || key==="필수아이템") return;
      // only keep allowed part names (fallback: keep anything that isn't obviously wrong)
      const part = PART_ALLOW.has(key) ? key : key;
      const arr = toNames(rp[key]).filter(Boolean);
      if(!arr.length) return;
      m[part] = (m[part]||[]);
      arr.forEach(n=>{
        if(n && !m[part].includes(n)) m[part].push(n);
      });
    });
    return m;
  }

  function renderReqPanel(stage, reqMap){
    const tips = document.getElementById('tips');
    if(!tips) return;
    // Remove any previous checklist
    tips.querySelectorAll('.reqlist').forEach(e=>e.remove());

    const ownedSet = window.ownedNameSet || new Set();
    const rows = Object.keys(reqMap).map(part=>{
      const names = reqMap[part].map(name=>{
        const owned = ownedSet.has(ownNorm(name));
        const cls = owned ? 'own' : 'miss';
        const icon = owned ? '✔' : '✖';
        return `<span class="pill ${cls}" title="${owned?'보유':'미보유'}">${icon} ${name}</span>`;
      }).join(' ');
      return `<div class="row" style="gap:8px;align-items:center"><span class="part">${part}</span>${names}</div>`;
    }).join('');

    const block = Object.keys(reqMap).length
      ? `<div class="reqlist"><div class="muted" style="margin-bottom:4px">필수 아이템</div>${rows}</div>`
      : '';

    if(block){
      // Insert at the very top
      const wrapper = document.createElement('div');
      wrapper.innerHTML = block;
      const node = wrapper.firstElementChild;
      tips.insertBefore(node, tips.firstChild || null);
    }
  }

  function addReqBadges(reqMap){
    const requiredNames = new Set();
    Object.values(reqMap).forEach(arr=> (arr||[]).forEach(n=> requiredNames.add(ownNorm(n))));
    document.querySelectorAll('#list .card').forEach(card=>{
      const nmEl = card.querySelector('h3 span');
      const badges = card.querySelector('.badges');
      if(!nmEl || !badges) return;
      const nm = ownNorm(nmEl.textContent||'');
      const has = requiredNames.has(nm);
      const b = badges.querySelector('.badge.req');
      if(has){
        if(!b){
          const el = document.createElement('span');
          el.className = 'badge req';
          el.textContent = '필수';
          badges.appendChild(el);
        }
      }else{
        if(b) b.remove();
      }
    });
  }

  function run(){
    const stage = getSelectedStage();
    const reqMap = buildReqMap(stage);
    renderReqPanel(stage, reqMap);
    addReqBadges(reqMap);
  }

  // Run safely without overriding render functions
  document.addEventListener('DOMContentLoaded', ()=>{
    setTimeout(run, 0);
    setTimeout(run, 200);
    document.addEventListener('change', (e)=>{
      if(e.target && e.target.id==='stageSelect'){
        setTimeout(run, 0);
      }
    });
    const list = document.getElementById('list');
    if(list){
      /* MO-off */ (null && new MutationObserver)(()=> run()).observe(list, {childList:true, subtree:true});
    }
    const tips = document.getElementById('tips');
    if(tips){
      /* MO-off */ (null && new MutationObserver)(()=>{
        // keep reqlist first
        const req = tips.querySelector('.reqlist');
        if(req && tips.firstChild !== req) tips/* disabled tips reorder */ void 0;
      }).observe(tips, {childList:true, subtree:true});
    }
  });
})();
</script>
<script>
(function(){
  const ownNorm = window.normOwnedName || (s=> String(s||'').toLowerCase().replace(/\s+/g,''));

  function getRequiredNameSet(){
    const sel = document.getElementById('stageSelect');
    const id = sel && sel.value;
    const st = (window.stages||[]).find(x=> String(x.stage_id)===String(id));
    const rp = st && st.required_parts;
    const names = new Set();
    if(rp && typeof rp==='object'){
      Object.values(rp).forEach(v=>{
        if(v==null) return;
        if(Array.isArray(v)) v.forEach(n=> names.add(ownNorm(String(n))));
        else if(typeof v==='object') Object.values(v).forEach(n=> names.add(ownNorm(String(n))));
        else names.add(ownNorm(String(v)));
      });
    }
    return names;
  }

  function reorderRequiredFirst(){
    const list = document.getElementById('list');
    if(!list) return;
    const req = getRequiredNameSet();
    if(!req.size) return;
    const cards = Array.from(list.querySelectorAll(':scope > .card'));
    if(!cards.length) return;

    const isReq = (card)=>{
      const nmEl = card.querySelector('h3 span');
      const nm = ownNorm(nmEl ? nmEl.textContent : '');
      return req.has(nm);
    };

    // Stable partition: required cards first, keep relative order otherwise
    const reqCards = [];
    const others = [];
    cards.forEach(c=> (isReq(c) ? reqCards : others).push(c));

    // If first already required, skip to avoid churn
    if(reqCards.length && cards[0] === reqCards[0]) return;

    const frag = document.createDocumentFragment();
    reqCards.concat(others).forEach(c=> frag.appendChild(c));
    list.appendChild(frag);
  }

  // Run after DOM ready and whenever list/tabs/filters change
  document.addEventListener('DOMContentLoaded', ()=>{
    setTimeout(reorderRequiredFirst, 0);
    setTimeout(reorderRequiredFirst, 200);

    document.addEventListener('change', (e)=>{
      if(e.target && (e.target.id==='stageSelect' || e.target.id==='ownOnly' || e.target.id==='groupSelect' || e.target.id==='sortSelect')){
        setTimeout(reorderRequiredFirst, 0);
      }
    });

    const list = document.getElementById('list');
    if(list){
      /* MO-off */ (null && new MutationObserver)(()=> reorderRequiredFirst()).observe(list, {childList:true, subtree:false});
    }
  });
})();
</script>

<script>
// Single-file datasets removed (use iframe/postMessage only);
window.stages = [{stage_id:"테스트-1", flair:1, simple:1, elegant:1, lively:1, chic:1, cute:1, sexy:1, pure:1, cool:1, 20%, 서브 큐티 10%"}];
window.ITEMS = window.items;

// Render hooks
function __populateStages(){
  const sel=document.getElementById('stageSelect'); if(!sel) return;
  const prev=sel.value;
  const list=Array.isArray(window.stages)?window.stages.slice():[];
  const seen=new Set();
  const dedup=list.filter(s=> s && s.stage_id && !seen.has(String(s.stage_id)) && (seen.add(String(s.stage_id))||true));
  function parseNum(id){ const m=String(id).match(/\[(?:[^\]]+)\]\s*(\d+)-(\d+)/); return m?[+m[1],+m[2]]:[9999,9999]; }
  dedup.sort((a,b)=>{ const A=parseNum(a.stage_id),B=parseNum(b.stage_id); if(A[0]!==B[0])return A[0]-B[0]; if(A[1]!==B[1])return A[1]-B[1]; return String(a.stage_id).localeCompare(String(b.stage_id)); });
  sel.innerHTML='';
  dedup.forEach(s=>{ const o=document.createElement('option'); o.value=s.stage_id; o.textContent=s.stage_id; sel.appendChild(o); });
  if(prev && Array.from(sel.options).some(o=>o.value===prev)) sel.value=prev;
  const cnt=document.getElementById('stageCount'); if(cnt) cnt.textContent=(window.stages||[]).length;
});
  const cnt = document.getElementById('stageCount');
  if (cnt) cnt.textContent = (window.stages||[]).length;
}

document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};
  try { __populateStages(); } catch(e) { console.warn(e); }
  try { if (typeof render === 'function') render(); } catch(e) { console.warn(e); }
});
</script>

<!-- data iframes (hidden) -->
<iframe id="itemsFrame" src="./items_frame_v2.html" style="display:none;width:0;height:0;border:0;"></iframe>
<iframe id="stagesFrame" src="./stages_frame_v2.html" style="display:none;width:0;height:0;border:0;"></iframe>


<script>
(function(){
  // Safe override of render() that avoids DOM reorders and freezes
  const by = (k)=> (a,b)=> String(a[k]||'').localeCompare(String(b[k]||''));
  const ownNorm = window.normOwnedName || (s=> String(s||'').toLowerCase().replace(/\s+/g,''));

  function getRequiredNameSetSafe(){
    try{
      const sel = document.getElementById('stageSelect');
      const id = sel && sel.value;
      const st = (window.stages||[]).find(x=> String(x.stage_id)===String(id));
      const rp = st && st.required_parts;
      const names = new Set();
      if(rp && typeof rp==='object'){
        Object.values(rp).forEach(v=>{
          if(Array.isArray(v)) v.forEach(n=> names.add(ownNorm(String(n))));
          else if(v && typeof v==='object') Object.values(v).forEach(n=> names.add(ownNorm(String(n))));
          else if(v!=null) names.add(ownNorm(String(v)));
        });
      }
      return names;
    }catch(e){ return new Set(); }
  }

  function scoreItemForStageSafe(item, stage){
    try{
      return (typeof window.scoreItemForStage==='function') ? window.scoreItemForStage(item, stage) : 0;
    }catch(e){ return 0; }
  }

  window.render = function(){
    try{
      const stageId=document.getElementById('stageSelect').value || (stages[0] && stages[0].stage_id);
      const sortBy=document.getElementById('sortBy').value;
      const ownedOnly=document.getElementById('ownedOnly').checked;
      const stage=(window.stages||[]).find(s=> String(s.stage_id)===String(stageId)) || (window.stages||[])[0];

      let list=(Array.isArray(window.items)?window.items:[]).map(it=> ({...it, part:it.part, score:scoreItemForStageSafe(it, stage)}));
      const part=document.getElementById('partFilter')?.value || '';
      if(part) list=list.filter(it=> it.part===part);
      if(ownedOnly && window.ownedNameSet && window.normOwnedName) list=list.filter(it=> window.ownedNameSet.has(window.normOwnedName(it.name)));

      // required-first sorting (data-level)
      const __reqSet = getRequiredNameSetSafe();
      list = list.map(it=> ({...it, __req: __reqSet.has(ownNorm(it.name||''))}));
      if(sortBy==='score') list.sort((a,b)=> (b.__req - a.__req) || (b.score-a.score));
      else list.sort((a,b)=> (b.__req - a.__req) || by('name')(a,b));

      const listEl=document.getElementById('list'); const empty=document.getElementById('emptyState');
      if(list.length===0){ listEl.style.display='none'; empty.style.display='block'; }
      else { listEl.style.display='grid'; empty.style.display='none'; }

      listEl.innerHTML = list.map(it=>{
        const stars=Math.max(0, Math.min(6, Number(it.stars||0)));
        const tgs = (window.getItemTags?window.parseTags((it && it.tags) ? it.tags : ''):(window.parseTags?window.parseTags(it.tags):[]));
        const img = it.img ? `<img class="thumb" src="${it.img}" alt="${it.name}">` : '';
        return `<div class="card">
          <div class="row thumbrow">${img}<h3 style="margin:0;flex:1;display:flex;justify-content:space-between;align-items:center">
            <span>${it.name||'-'}</span>
            <button class="copy-btn" onclick="copyText('${(it.name||'').replace(/'/g, "\'")}')">이름 복사</button>
          </h3></div>
          <div class="badges"><span class="badge">${it.part||'-'}</span><span class="badge">${stars}★</span>${it._owned?'<span class="badge owned">보유</span>':''}</div>
          <div class="badges tags">${tgs.map(x=>`<span class='badge tag'>#${x}</span>`).join('')}</div>
          <div class="score">점수: ${Number(it.score).toFixed(2)}</div>
        </div>`;
      }).join('');
    }catch(e){ /* swallow */ }
  };

  // After override: stop invoking DOM-reorder helpers if present
  window.reorderRequiredFirst = function(){};
  window.moveRequiredFirst = function(){};

  // Kick initial render once items become available
  (function waitItems(){
    if(Array.isArray(window.items) && window.items.length){
      try{ window.renderAll ? window.renderAll() : window.render(); }catch(e){}
    }else{
      setTimeout(waitItems, 100);
    }
  })();
})();
</script>


<script>
(function(){
  const ownNorm = window.normOwnedName || (s=> String(s||'').toLowerCase().replace(/\s+/g,''));
  const by = (k)=> (a,b)=> String(a[k]||'').localeCompare(String(b[k]||''));

  function getStageAndReq(){
    const sel = document.getElementById('stageSelect');
    const id = sel && sel.value;
    const st = (window.stages||[]).find(x=> String(x.stage_id)===String(id)) || (window.stages||[])[0] || null;
    const rp = st && st.required_parts || {};
    const reqNames = new Set();
    const reqByPart = {};
    if(rp && typeof rp==='object'){
      Object.keys(rp).forEach(part=>{
        const arr = Array.isArray(rp[part]) ? rp[part] : [];
        if(arr.length){
          reqByPart[part] = arr.slice();
          arr.forEach(n=> reqNames.add(ownNorm(String(n))));
        }
      });
    }
    return {stage:st, reqSet:reqNames, reqByPart};
  }

  function renderReqPanel(reqByPart){
    const panel = document.getElementById('reqPanel');
    if(!panel) return;
    const parts = Object.keys(reqByPart);
    if(!parts.length){ panel.style.display='none'; panel.innerHTML=''; return; }
    const rows = parts.map(p=>{
      const names = reqByPart[p].map(n=> `<code>${n}</code>`).join(', ');
      return `<tr><th>${p}</th><td>${names}</td></tr>`;
    }).join('');
    panel.innerHTML = `<h3>필수아이템</h3><table class="req-table"><tbody>${rows}</tbody></table>`;
    panel.style.display='block';
  }

  // Preserve original score function if exists
  const scoreSafe = (item, stage)=>{
    try{ return (typeof window.scoreItemForStage==='function') ? window.scoreItemForStage(item, stage) : 0; }
    catch(e){ return 0; }
  };

  // Override render ONLY (renderAll는 기존 로직을 쓰되 render를 호출하도록 둠)
  window.render = function(){
    try{
      const {stage, reqSet, reqByPart} = getStageAndReq();
      renderReqPanel(reqByPart);

      const part=document.getElementById('partFilter')?.value || '';
      const sortBy=document.getElementById('sortBy')?.value || 'score';
      const ownedOnly=document.getElementById('ownedOnly')?.checked || false;

      let src = Array.isArray(window.items)? window.items : [];
      let list = src.map(it=> ({...it, score:scoreSafe(it, stage)}));
      if(part) list = list.filter(it=> it.part===part);
      if(ownedOnly && window.ownedNameSet && window.normOwnedName){
        list = list.filter(it=> window.ownedNameSet.has(window.normOwnedName(it.name)));
      }

      list = list.map(it=> ({...it, __req: reqSet.has(ownNorm(it.name||''))}));
      if(sortBy==='score') list.sort((a,b)=> (b.__req - a.__req) || (b.score-a.score));
      else list.sort((a,b)=> (b.__req - a.__req) || by('name')(a,b));

      const listEl=document.getElementById('list'); const empty=document.getElementById('emptyState');
      if(!listEl) return;
      if(list.length===0){ listEl.style.display='none'; if(empty) empty.style.display='block'; }
      else { listEl.style.display='grid'; if(empty) empty.style.display='none'; }

      listEl.innerHTML = list.map(it=>{
        const stars = Math.max(0, Math.min(6, Number(it.stars||0)));
        const tgs = (window.getItemTags?window.parseTags((it && it.tags) ? it.tags : ''):(window.parseTags?window.parseTags(it.tags):[]));
        const img = it.img ? `<img class="thumb" src="${it.img}" alt="${it.name}">` : '';
        const reqBadge = it.__req ? `<span class="req-badge">필수</span>` : '';
        return `<div class="card">
          <div class="row thumbrow">${img}<h3 style="margin:0;flex:1;display:flex;justify-content:space-between;align-items:center">
            <span>${it.name||'-'} ${reqBadge}</span>
            <button class="copy-btn" onclick="copyText('${(it.name||'').replace(/'/g, "\\'")}')">이름 복사</button>
          </h3></div>
          <div class="badges"><span class="badge">${it.part||'-'}</span><span class="badge">${stars}★</span>${it._owned?'<span class="badge owned">보유</span>':''}</div>
          <div class="badges tags">${tgs.map(x=>`<span class='badge tag'>#${x}</span>`).join('')}</div>
          <div class="score">점수: ${Number(it.score).toFixed(2)}</div>
        </div>`;
      }).join('');
    }catch(e){ /* swallow */ }
  };

  // Ensure first render when items become available
  (function waitItems(){
    if(Array.isArray(window.items) && window.items.length){
      try{ window.renderAll ? window.renderAll() : window.render(); }catch(e){}
    }else{
      setTimeout(waitItems, 100);
    }
  })();
})();
</script>


<script>
(function(){
  const norm = s => String(s||'').trim();
  const split = s => String(s||'').split(/[;,\|\/·\u3001\u3002\uFF0C\uFF0E\[\]\(\)\{\}\s]+/).map(x=>x.trim()).filter(Boolean);
  const uniq = arr => Array.from(new Set(arr.map(norm))).filter(Boolean);
  function deepCollectStrings(obj, bucket){
    if(!obj) return;
    const t = typeof obj;
    if(t==='string'){ bucket.push(obj); return; }
    if(t!=='object') return;
    if(Array.isArray(obj)){ for(const v of obj) deepCollectStrings(v, bucket); return; }
    for(const k in obj){
      if(/img|image|thumb|url/i.test(k)) continue;
      deepCollectStrings(obj[k], bucket);
    }
  }
  window.getItemTags = function(it){
    try{
      let raw = it.tags ?? it.tag ?? it["태그"] ?? "";
      let list = Array.isArray(raw) ? raw.map(norm) : split(raw);
      if(list.length===0){
        if(it.tag_list) list = Array.isArray(it.tag_list) ? it.tag_list : split(it.tag_list);
        if(it.Tags) list = list.concat(split(it.Tags));
      }
      if(list.length===0){
        const buf=[]; deepCollectStrings(it, buf);
        const words = buf.join(" ");
        list = uniq((words.match(/[#\u0023]?([가-힣A-Za-z0-9]+(?:스타일)?)/g) || []).map(s=>s.replace(/^#/,"")));
      }
      return uniq(list);
    }catch(e){ return []; }
  };
})();
</script>


<!-- Auto Tag Bonus Patch (append) -->
<script>
(function(){
  // 1) Global tag bonus (editable)
  window.TAG_BONUS_PCT = (typeof window.TAG_BONUS_PCT === 'number') ? window.TAG_BONUS_PCT : 30;

  // 2) Extract tags from stage.tip1 (e.g., "..., 태그 유럽풍 30%, 드레스 30%")
  if(typeof window.tagsFromStage !== 'function'){
    window.tagsFromStage = function(stage){
      try{
        const out = [];
        if(!stage) return out;
        const t = String(stage.tip1||"");
        const i = t.indexOf("태그");
        if(i === -1) return out;
        const s = t.slice(i + 2); // after "태그"
        s.split(/[\s,·]+/).forEach(tok=>{
          const x = String(tok||"")
            .replace(/[%\d]+/g,"")
            .trim();
          if(x && x !== "태그") out.push(x);
        });
        return Array.from(new Set(out));
      }catch(e){ return []; }
    };
  }

  // 3) Monkey-patch scoreItemForStage to inject tag bonus (once)
  if(typeof window.scoreItemForStage === 'function'){
    const _orig = window.scoreItemForStage;
    window.scoreItemForStage = function(item, stage){
      let out = _orig(item, stage);
      try{
        const stageTags = (window.tagsFromStage ? window.tagsFromStage(stage) : []);
        // parse item tags: either array, or comma/space separated string
        const raw = item && item.tags;
        const itemTags = Array.isArray(raw) ? raw :
          String(raw||'').split(/[#,;\s,·]+/).filter(Boolean);
        const hit = stageTags.length ? stageTags.some(t => itemTags.includes(t)) : false;
        if(hit){
          out = out * (1 + (window.TAG_BONUS_PCT||30)/100);
        }
      }catch(e){ /* ignore */ }
      return out;
    };
    // expose for quick sanity check
    window.__tag_patch_installed__ = true;
  }
})();
</script>


<script>
// === Unified Tag Bonus Control (Single Source) ===
// Edit ONLY this block to change tag mappings or bonus percent.
(function(){

  // Stage-specific tag mapping
  const STAGE_TAGS = {
    "[메인] 1-4 이성과 감정": ["걸그룹스타일"],
    "[메인] 1-6 의혹 속으로": ["운동룩"],
    "[메인] 1-7 '흑역사'": ["드레스"],
    "[메인] 1-8 알지 못했던 일들": ["애니멀"],
    "[메인] 1-9 어둠 속에서": ["젠더리스"],
    "[메인] 1-11 파도가 친 뒤의 고요함" : ["홈웨어"],
    "[메인] 1-12 깊어진 밤하늘" : ["바캉스스타일"],
    "[메인] 2-4 비어있는 기억" : ["동화풍"],
    "[메인] 2-5 폭풍 전야" : ["성숙한스타일"],
    "[메인] 2-8 가족의 이름으로" : ["걸그룹스타일"],
    "[메인] 3-1 진실을 가린 그림자" : ["스트릿펑크"],
    "[메인] 3-6 마음의 기억" : ["걸그룹스타일"],
    "[메인] 3-7 기억 속의 무대" : ["핫걸"],
    "[메인] 3-11 남은 세 사람" : ["스쿨룩"],
    "[메인] 4-2 슬픈 노래" : ["홈웨어"],
    "[메인] 4-4 거래" : ["성숙한스타일"],
    "[메인] 4-5 약속" : ["스트릿펑크"],
    "[메인] 4-10 그녀의 '깃털'" : ["드레스"],
    "[메인] 5-7 통찰'" : ["모리걸"],
    "[메인] 5-8 암실'" : ["드레스"],
    "[메인] 6-2 어둠 속 불빛'" : ["유럽풍"],
    "[메인] 6-5 드러나는 진실": ["트렌디스냅샷"]
    "[메인] 6-9 끝없는 대낮": ["중국풍"]
  };

  // Global tag bonus percent (applied multiplicatively ONCE)
  const TAG_BONUS_PCT = 30;

  // Keep reference to original scoring
  const _origScore = window.scoreItemForStage || scoreItemForStage;

  // Tag parser (splits by whitespace, comma, semicolon)
  const parseTags = (t)=> String(t||'').split(/[;,\s]+/).map(s=>s.trim()).filter(Boolean);

  window.scoreItemForStage = function(item, stage){
    let score = _origScore(item, stage); // already includes star*part multipliers
    try{
      if(!item || !stage) return score;
      const sid = String(stage.stage_id||"");
      const stageTags = STAGE_TAGS[sid] || [];
      if(stageTags.length === 0) return score;
      const itemTags = parseTags(item.tags);
      const hit = stageTags.some(t => itemTags.includes(t));
      if(hit){
        score *= (1 + TAG_BONUS_PCT/100);
      }
    }catch(e){ /* no-op */ }
    return score;
  };

})();
// === End Unified Tag Bonus Control ===
</script>
</body>
</html>
<script>(function(){if(!window.__bootDone){window.__bootDone=false;}function canInit(){try{return Array.isArray(window.items)&&window.items.length>0&&Array.isArray(window.stages)&&window.stages.length>0;}catch(e){return false;}}function tryInitNow(){if(window.__bootDone)return;if(canInit()){window.__bootDone=true;if(typeof init==='function')init();return true;}return false;}document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};if(tryInitNow())return;let n=0;const t=setInterval(function(){n++;if(tryInitNow()||n>30){clearInterval(t);}},200);});window.addEventListener('load',tryInitNow);window.addEventListener('message',function(){setTimeout(tryInitNow,0);},true);})();</script>
<script>(function(){function ex(h){const m=h.match(/var\s+data\s*=\s*(\[[\s\S]*?\]);/);return m?m[1]:null;}async function fetchArr(u){try{const r=await fetch(u,{credentials:'same-origin'});if(!r.ok)return null;const h=await r.text();const t=ex(h);if(!t)return null;const a=Function('\"use strict\";return ('+t+')')();return Array.isArray(a)?a:null;}catch(_){return null;}}async function go(){if(!(window.items&&window.items.length)){const a=await fetchArr('items_frame_v2.html');if(a){window.items=a;items=window.items;if(window.got)window.got.items=true;}}if(!(window.stages&&window.stages.length)){const a2=await fetchArr('stages_frame_v2.html');if(a2){window.stages=a2;stages=window.stages;if(window.got)window.got.stages=true;}}if(typeof maybeInit==='function')maybeInit();}document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};setTimeout(go,800);});})();</script>
<script>// Iframe onload fallback
(function(){function ex(h){const m=h&&h.match(/var\s+data\s*=\s*(\[[\s\S]*?\]);/);return m?m[1]:null;}function parseIF(f){try{const d=f&&f.contentDocument;const h=d&&d.documentElement&&d.documentElement.innerHTML;const t=ex(h||'');if(!t)return null;const a=Function('\"use strict\";return ('+t+')')();return Array.isArray(a)?a:null;}catch(_){return null;}}function go(){var i=document.querySelector('iframe[src="./items_frame_v2.html"]');var s2=document.querySelector('iframe[src="./stages_frame_v2.html"]');if(i&&!(window.items&&window.items.length)){var a=parseIF(i);if(a){window.items=a;items=window.items;if(window.got)window.got.items=true;}}if(s2&&!(window.stages&&window.stages.length)){var a2=parseIF(s2);if(a2){window.stages=a2;stages=window.stages;if(window.got)window.got.stages=true;}}if(typeof maybeInit==='function')maybeInit();}window.addEventListener('load',function(){setTimeout(go,400);});document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};var i=document.querySelector('iframe[src="./items_frame_v2.html"]');var s2=document.querySelector('iframe[src="./stages_frame_v2.html"]');function onIF(){setTimeout(go,50);}if(i)i.addEventListener('load',onIF);if(s2)s2.addEventListener('load',onIF);});})();</script>
<script>
(function(){
  function hasData(a){ return Array.isArray(a) && a.length>0; }
  function refreshCountsNow(){
    try{
      if (typeof computeOwnedTotal === 'function'){
        var res = computeOwnedTotal();
        var badge = document.querySelector('#ownedSummary strong');
        if (badge) badge.textContent = '보유 ' + res.owned + ' / 전체 ' + (res.total||0);
      }
      if (typeof renderPartCounts === 'function') renderPartCounts();
    }catch(e){ console.warn('refreshCountsNow', e); }
  }
  // Recompute on textarea typing/paste
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};
    var ta = document.getElementById('ownedInput');
    if (ta){
      ['input','change','blur'].forEach(function(ev){
        ta.addEventListener(ev, function(){ setTimeout(refreshCountsNow,0); });
      });
    }
  });

  // Re-render when datasets arrive via postMessage
  window.addEventListener('message', function(ev){
    var d = ev && ev.data;
    if (!d || !d.__splitData) return;
    // Give original handlers a tick to assign window.items/stages
    setTimeout(function(){
      if (typeof renderAll === 'function' && hasData(window.items) && hasData(window.stages)){
        renderAll(); refreshCountsNow();
      }
    },0);
  }, true);
})();
</script>
